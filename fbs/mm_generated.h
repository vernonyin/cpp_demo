// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MM_MM_H_
#define FLATBUFFERS_GENERATED_MM_MM_H_

#include "flatbuffers/flatbuffers.h"

namespace mm {

struct Pair;

struct Result;

struct Bank;

struct Banks;

struct Account;

struct Query_page;

struct Deal_summary;

struct Deal_detail;

struct Capital_detail;

struct Fee;

struct Entrust;

struct SpecialCond;

struct Login;

struct Login_rsp;

struct ChangePwd;

struct QueryConsign;

struct QueryConsign_rsp;

struct Query_hold;

struct Query_hold_rsp;

struct Query_fund;

struct Query_fund_rsp;

struct QueryBargain;

struct QueryBargain_rsp;

struct QueryCapital;

struct Query_capital_rsp;

struct FundTransfer;

struct Query_ftflow;

struct Query_ftflow_rsp;

struct QueryPosition;

struct Query_position_rsp;

struct Query_settlement;

struct Query_settlement_rsp;

struct Query_maxbuy;

struct Query_maxbuy_rsp;

struct Entrust_rsp;

struct EntrustAll;

struct Exrate;

struct Exrates;

struct Product;

struct Product_rsp;

struct Query_products;

struct Query_products_rsp;

struct MarginScalingClassDetail;

struct MarginScalingClass;

struct AccountInfo;

struct UserInfo;

struct Fund;

struct Hold;

struct PositionNotify;

struct Notify;

struct Margin;

struct Recovery;

struct VerifyCode_req;

struct VerifyCode_rsp;

struct exrates_req;

struct Query_order_oprecord;

struct Order_operation_record;

struct Query_order_oprecord_rsp;

struct ACCOUNT_INFO;

enum CashIOType {
  CashIOType_NONE = 0,
  CashIOType_Withdraw = 1,
  CashIOType_Deposit = 2,
  CashIOType_DepositChq = 3,
  CashIOType_SellIn = 4,
  CashIOType_BuyOut = 5,
  CashIOType_MIN = CashIOType_NONE,
  CashIOType_MAX = CashIOType_BuyOut
};

inline CashIOType (&EnumValuesCashIOType())[6] {
  static CashIOType values[] = {
    CashIOType_NONE,
    CashIOType_Withdraw,
    CashIOType_Deposit,
    CashIOType_DepositChq,
    CashIOType_SellIn,
    CashIOType_BuyOut
  };
  return values;
}

inline const char **EnumNamesCashIOType() {
  static const char *names[] = {
    "NONE",
    "Withdraw",
    "Deposit",
    "DepositChq",
    "SellIn",
    "BuyOut",
    nullptr
  };
  return names;
}

inline const char *EnumNameCashIOType(CashIOType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesCashIOType()[index];
}

enum CashMedia {
  CashMedia_NONE = 0,
  CashMedia_Counter = 1,
  CashMedia_ATM = 2,
  CashMedia_Box = 3,
  CashMedia_Transfer = 4,
  CashMedia_Other = 5,
  CashMedia_MIN = CashMedia_NONE,
  CashMedia_MAX = CashMedia_Other
};

inline CashMedia (&EnumValuesCashMedia())[6] {
  static CashMedia values[] = {
    CashMedia_NONE,
    CashMedia_Counter,
    CashMedia_ATM,
    CashMedia_Box,
    CashMedia_Transfer,
    CashMedia_Other
  };
  return values;
}

inline const char **EnumNamesCashMedia() {
  static const char *names[] = {
    "NONE",
    "Counter",
    "ATM",
    "Box",
    "Transfer",
    "Other",
    nullptr
  };
  return names;
}

inline const char *EnumNameCashMedia(CashMedia e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesCashMedia()[index];
}

enum SettleType {
  SettleType_NONE = 0,
  SettleType_DaySett = 1,
  SettleType_MonSett = 2,
  SettleType_MIN = SettleType_NONE,
  SettleType_MAX = SettleType_MonSett
};

inline SettleType (&EnumValuesSettleType())[3] {
  static SettleType values[] = {
    SettleType_NONE,
    SettleType_DaySett,
    SettleType_MonSett
  };
  return values;
}

inline const char **EnumNamesSettleType() {
  static const char *names[] = {
    "NONE",
    "DaySett",
    "MonSett",
    nullptr
  };
  return names;
}

inline const char *EnumNameSettleType(SettleType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesSettleType()[index];
}

enum Action {
  Action_NONE = 0,
  Action_Kickoff = 1,
  Action_Warn = 2,
  Action_Notify = 3,
  Action_More = 4,
  Action_Timeout = 5,
  Action_Acc_Reset = 6,
  Action_Counter_Lineoff = 7,
  Action_MIN = Action_NONE,
  Action_MAX = Action_Counter_Lineoff
};

inline Action (&EnumValuesAction())[8] {
  static Action values[] = {
    Action_NONE,
    Action_Kickoff,
    Action_Warn,
    Action_Notify,
    Action_More,
    Action_Timeout,
    Action_Acc_Reset,
    Action_Counter_Lineoff
  };
  return values;
}

inline const char **EnumNamesAction() {
  static const char *names[] = {
    "NONE",
    "Kickoff",
    "Warn",
    "Notify",
    "More",
    "Timeout",
    "Acc_Reset",
    "Counter_Lineoff",
    nullptr
  };
  return names;
}

inline const char *EnumNameAction(Action e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesAction()[index];
}

enum Market {
  Market_NONE = 0,
  Market_HKEX = 1,
  Market_HKF = 2,
  Market_CME = 3,
  Market_CBOT = 4,
  Market_COMEX = 5,
  Market_NYMEX = 6,
  Market_LME = 7,
  Market_SGX = 8,
  Market_PUROX = 9,
  Market_MIN = Market_NONE,
  Market_MAX = Market_PUROX
};

inline Market (&EnumValuesMarket())[10] {
  static Market values[] = {
    Market_NONE,
    Market_HKEX,
    Market_HKF,
    Market_CME,
    Market_CBOT,
    Market_COMEX,
    Market_NYMEX,
    Market_LME,
    Market_SGX,
    Market_PUROX
  };
  return values;
}

inline const char **EnumNamesMarket() {
  static const char *names[] = {
    "NONE",
    "HKEX",
    "HKF",
    "CME",
    "CBOT",
    "COMEX",
    "NYMEX",
    "LME",
    "SGX",
    "PUROX",
    nullptr
  };
  return names;
}

inline const char *EnumNameMarket(Market e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMarket()[index];
}

enum Entrust_mode {
  Entrust_mode_NONE = 0,
  Entrust_mode_Buy = 1,
  Entrust_mode_Sell = 2,
  Entrust_mode_Cancel = 3,
  Entrust_mode_Update = 4,
  Entrust_mode_Clear = 5,
  Entrust_mode_MIN = Entrust_mode_NONE,
  Entrust_mode_MAX = Entrust_mode_Clear
};

inline Entrust_mode (&EnumValuesEntrust_mode())[6] {
  static Entrust_mode values[] = {
    Entrust_mode_NONE,
    Entrust_mode_Buy,
    Entrust_mode_Sell,
    Entrust_mode_Cancel,
    Entrust_mode_Update,
    Entrust_mode_Clear
  };
  return values;
}

inline const char **EnumNamesEntrust_mode() {
  static const char *names[] = {
    "NONE",
    "Buy",
    "Sell",
    "Cancel",
    "Update",
    "Clear",
    nullptr
  };
  return names;
}

inline const char *EnumNameEntrust_mode(Entrust_mode e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEntrust_mode()[index];
}

enum Price_mode {
  Price_mode_NONE = 0,
  Price_mode_PL = 1,
  Price_mode_EL = 2,
  Price_mode_SL = 3,
  Price_mode_M = 4,
  Price_mode_AO = 5,
  Price_mode_MIN = Price_mode_NONE,
  Price_mode_MAX = Price_mode_AO
};

inline Price_mode (&EnumValuesPrice_mode())[6] {
  static Price_mode values[] = {
    Price_mode_NONE,
    Price_mode_PL,
    Price_mode_EL,
    Price_mode_SL,
    Price_mode_M,
    Price_mode_AO
  };
  return values;
}

inline const char **EnumNamesPrice_mode() {
  static const char *names[] = {
    "NONE",
    "PL",
    "EL",
    "SL",
    "M",
    "AO",
    nullptr
  };
  return names;
}

inline const char *EnumNamePrice_mode(Price_mode e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesPrice_mode()[index];
}

enum Deal_mode {
  Deal_mode_NONE = 0,
  Deal_mode_FAK = 1,
  Deal_mode_FOK = 2,
  Deal_mode_GTD = 3,
  Deal_mode_GTC = 4,
  Deal_mode_MIN = Deal_mode_NONE,
  Deal_mode_MAX = Deal_mode_GTC
};

inline Deal_mode (&EnumValuesDeal_mode())[5] {
  static Deal_mode values[] = {
    Deal_mode_NONE,
    Deal_mode_FAK,
    Deal_mode_FOK,
    Deal_mode_GTD,
    Deal_mode_GTC
  };
  return values;
}

inline const char **EnumNamesDeal_mode() {
  static const char *names[] = {
    "NONE",
    "FAK",
    "FOK",
    "GTD",
    "GTC",
    nullptr
  };
  return names;
}

inline const char *EnumNameDeal_mode(Deal_mode e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesDeal_mode()[index];
}

enum Entrust_status {
  Entrust_status_NONE = 0,
  Entrust_status_RECV = 1,
  Entrust_status_ABA = 2,
  Entrust_status_NEW = 3,
  Entrust_status_WA = 4,
  Entrust_status_PRO = 5,
  Entrust_status_Q = 6,
  Entrust_status_REJ = 7,
  Entrust_status_CAN = 8,
  Entrust_status_PCAN = 9,
  Entrust_status_PEX = 10,
  Entrust_status_FEX = 11,
  Entrust_status_MIN = Entrust_status_NONE,
  Entrust_status_MAX = Entrust_status_FEX
};

inline Entrust_status (&EnumValuesEntrust_status())[12] {
  static Entrust_status values[] = {
    Entrust_status_NONE,
    Entrust_status_RECV,
    Entrust_status_ABA,
    Entrust_status_NEW,
    Entrust_status_WA,
    Entrust_status_PRO,
    Entrust_status_Q,
    Entrust_status_REJ,
    Entrust_status_CAN,
    Entrust_status_PCAN,
    Entrust_status_PEX,
    Entrust_status_FEX
  };
  return values;
}

inline const char **EnumNamesEntrust_status() {
  static const char *names[] = {
    "NONE",
    "RECV",
    "ABA",
    "NEW",
    "WA",
    "PRO",
    "Q",
    "REJ",
    "CAN",
    "PCAN",
    "PEX",
    "FEX",
    nullptr
  };
  return names;
}

inline const char *EnumNameEntrust_status(Entrust_status e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEntrust_status()[index];
}

enum Op_status {
  Op_status_SUCC = 0,
  Op_status_CR = 1,
  Op_status_REJ = 2,
  Op_status_MIN = Op_status_SUCC,
  Op_status_MAX = Op_status_REJ
};

inline Op_status (&EnumValuesOp_status())[3] {
  static Op_status values[] = {
    Op_status_SUCC,
    Op_status_CR,
    Op_status_REJ
  };
  return values;
}

inline const char **EnumNamesOp_status() {
  static const char *names[] = {
    "SUCC",
    "CR",
    "REJ",
    nullptr
  };
  return names;
}

inline const char *EnumNameOp_status(Op_status e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesOp_status()[index];
}

enum TerminalType {
  TerminalType_NONE = 0,
  TerminalType_PC = 1,
  TerminalType_WEB = 2,
  TerminalType_ANDROID = 3,
  TerminalType_IPHONE = 4,
  TerminalType_AE = 5,
  TerminalType_MAC = 6,
  TerminalType_SERVER = 7,
  TerminalType_MIN = TerminalType_NONE,
  TerminalType_MAX = TerminalType_SERVER
};

inline TerminalType (&EnumValuesTerminalType())[8] {
  static TerminalType values[] = {
    TerminalType_NONE,
    TerminalType_PC,
    TerminalType_WEB,
    TerminalType_ANDROID,
    TerminalType_IPHONE,
    TerminalType_AE,
    TerminalType_MAC,
    TerminalType_SERVER
  };
  return values;
}

inline const char **EnumNamesTerminalType() {
  static const char *names[] = {
    "NONE",
    "PC",
    "WEB",
    "ANDROID",
    "IPHONE",
    "AE",
    "MAC",
    "SERVER",
    nullptr
  };
  return names;
}

inline const char *EnumNameTerminalType(TerminalType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesTerminalType()[index];
}

enum Page_mode {
  Page_mode_ALL = 0,
  Page_mode_SYNC = 1,
  Page_mode_ASYNC = 2,
  Page_mode_MIN = Page_mode_ALL,
  Page_mode_MAX = Page_mode_ASYNC
};

inline Page_mode (&EnumValuesPage_mode())[3] {
  static Page_mode values[] = {
    Page_mode_ALL,
    Page_mode_SYNC,
    Page_mode_ASYNC
  };
  return values;
}

inline const char **EnumNamesPage_mode() {
  static const char *names[] = {
    "ALL",
    "SYNC",
    "ASYNC",
    nullptr
  };
  return names;
}

inline const char *EnumNamePage_mode(Page_mode e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesPage_mode()[index];
}

enum Lang {
  Lang_ENG = 0,
  Lang_CHS = 1,
  Lang_CHT = 2,
  Lang_MIN = Lang_ENG,
  Lang_MAX = Lang_CHT
};

inline Lang (&EnumValuesLang())[3] {
  static Lang values[] = {
    Lang_ENG,
    Lang_CHS,
    Lang_CHT
  };
  return values;
}

inline const char **EnumNamesLang() {
  static const char *names[] = {
    "ENG",
    "CHS",
    "CHT",
    nullptr
  };
  return names;
}

inline const char *EnumNameLang(Lang e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesLang()[index];
}

enum ProductType {
  ProductType_NONE = 0,
  ProductType_FUT = 1,
  ProductType_OPT = 2,
  ProductType_EQTY = 3,
  ProductType_MIN = ProductType_NONE,
  ProductType_MAX = ProductType_EQTY
};

inline ProductType (&EnumValuesProductType())[4] {
  static ProductType values[] = {
    ProductType_NONE,
    ProductType_FUT,
    ProductType_OPT,
    ProductType_EQTY
  };
  return values;
}

inline const char **EnumNamesProductType() {
  static const char *names[] = {
    "NONE",
    "FUT",
    "OPT",
    "EQTY",
    nullptr
  };
  return names;
}

inline const char *EnumNameProductType(ProductType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesProductType()[index];
}

enum ProductSubType {
  ProductSubType_NONE = 0,
  ProductSubType_F = 1,
  ProductSubType_S = 2,
  ProductSubType_C = 3,
  ProductSubType_P = 4,
  ProductSubType_EQTY = 5,
  ProductSubType_BOND = 6,
  ProductSubType_TRST = 7,
  ProductSubType_WRNT = 8,
  ProductSubType_MIN = ProductSubType_NONE,
  ProductSubType_MAX = ProductSubType_WRNT
};

inline ProductSubType (&EnumValuesProductSubType())[9] {
  static ProductSubType values[] = {
    ProductSubType_NONE,
    ProductSubType_F,
    ProductSubType_S,
    ProductSubType_C,
    ProductSubType_P,
    ProductSubType_EQTY,
    ProductSubType_BOND,
    ProductSubType_TRST,
    ProductSubType_WRNT
  };
  return values;
}

inline const char **EnumNamesProductSubType() {
  static const char *names[] = {
    "NONE",
    "F",
    "S",
    "C",
    "P",
    "EQTY",
    "BOND",
    "TRST",
    "WRNT",
    nullptr
  };
  return names;
}

inline const char *EnumNameProductSubType(ProductSubType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesProductSubType()[index];
}

enum Status {
  Status_NONE = 0,
  Status_A = 1,
  Status_S = 2,
  Status_C = 3,
  Status_MIN = Status_NONE,
  Status_MAX = Status_C
};

inline Status (&EnumValuesStatus())[4] {
  static Status values[] = {
    Status_NONE,
    Status_A,
    Status_S,
    Status_C
  };
  return values;
}

inline const char **EnumNamesStatus() {
  static const char *names[] = {
    "NONE",
    "A",
    "S",
    "C",
    nullptr
  };
  return names;
}

inline const char *EnumNameStatus(Status e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesStatus()[index];
}

enum Currency {
  Currency_NONE = 0,
  Currency_CNY = 1,
  Currency_HKD = 2,
  Currency_USD = 3,
  Currency_JPY = 4,
  Currency_EUR = 5,
  Currency_GBP = 6,
  Currency_SGD = 7,
  Currency_CAD = 8,
  Currency_AUD = 9,
  Currency_KRW = 10,
  Currency_TWD = 11,
  Currency_IDR = 12,
  Currency_MYR = 13,
  Currency_THB = 14,
  Currency_CNH = 15,
  Currency_RUB = 16,
  Currency_BND = 17,
  Currency_CHF = 18,
  Currency_DKK = 19,
  Currency_INR = 20,
  Currency_MOP = 21,
  Currency_NOK = 22,
  Currency_NZD = 23,
  Currency_PHP = 24,
  Currency_SEK = 25,
  Currency_ZAR = 26,
  Currency_ZRH = 27,
  Currency_MIN = Currency_NONE,
  Currency_MAX = Currency_ZRH
};

inline Currency (&EnumValuesCurrency())[28] {
  static Currency values[] = {
    Currency_NONE,
    Currency_CNY,
    Currency_HKD,
    Currency_USD,
    Currency_JPY,
    Currency_EUR,
    Currency_GBP,
    Currency_SGD,
    Currency_CAD,
    Currency_AUD,
    Currency_KRW,
    Currency_TWD,
    Currency_IDR,
    Currency_MYR,
    Currency_THB,
    Currency_CNH,
    Currency_RUB,
    Currency_BND,
    Currency_CHF,
    Currency_DKK,
    Currency_INR,
    Currency_MOP,
    Currency_NOK,
    Currency_NZD,
    Currency_PHP,
    Currency_SEK,
    Currency_ZAR,
    Currency_ZRH
  };
  return values;
}

inline const char **EnumNamesCurrency() {
  static const char *names[] = {
    "NONE",
    "CNY",
    "HKD",
    "USD",
    "JPY",
    "EUR",
    "GBP",
    "SGD",
    "CAD",
    "AUD",
    "KRW",
    "TWD",
    "IDR",
    "MYR",
    "THB",
    "CNH",
    "RUB",
    "BND",
    "CHF",
    "DKK",
    "INR",
    "MOP",
    "NOK",
    "NZD",
    "PHP",
    "SEK",
    "ZAR",
    "ZRH",
    nullptr
  };
  return names;
}

inline const char *EnumNameCurrency(Currency e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesCurrency()[index];
}

enum CommMode {
  CommMode_NONE = 0,
  CommMode_P = 1,
  CommMode_RR = 2,
  CommMode_MIN = CommMode_NONE,
  CommMode_MAX = CommMode_RR
};

inline CommMode (&EnumValuesCommMode())[3] {
  static CommMode values[] = {
    CommMode_NONE,
    CommMode_P,
    CommMode_RR
  };
  return values;
}

inline const char **EnumNamesCommMode() {
  static const char *names[] = {
    "NONE",
    "P",
    "RR",
    nullptr
  };
  return names;
}

inline const char *EnumNameCommMode(CommMode e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesCommMode()[index];
}

enum SpecialType {
  SpecialType_NONE = 0,
  SpecialType_SL = 1,
  SpecialType_UT = 2,
  SpecialType_DT = 3,
  SpecialType_TR = 4,
  SpecialType_OCO = 5,
  SpecialType_TCLS = 6,
  SpecialType_MIN = SpecialType_NONE,
  SpecialType_MAX = SpecialType_TCLS
};

inline SpecialType (&EnumValuesSpecialType())[7] {
  static SpecialType values[] = {
    SpecialType_NONE,
    SpecialType_SL,
    SpecialType_UT,
    SpecialType_DT,
    SpecialType_TR,
    SpecialType_OCO,
    SpecialType_TCLS
  };
  return values;
}

inline const char **EnumNamesSpecialType() {
  static const char *names[] = {
    "NONE",
    "SL",
    "UT",
    "DT",
    "TR",
    "OCO",
    "TCLS",
    nullptr
  };
  return names;
}

inline const char *EnumNameSpecialType(SpecialType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesSpecialType()[index];
}

enum MarginMode {
  MarginMode_SPAN = 0,
  MarginMode_NET = 1,
  MarginMode_MIN = MarginMode_SPAN,
  MarginMode_MAX = MarginMode_NET
};

inline MarginMode (&EnumValuesMarginMode())[2] {
  static MarginMode values[] = {
    MarginMode_SPAN,
    MarginMode_NET
  };
  return values;
}

inline const char **EnumNamesMarginMode() {
  static const char *names[] = {
    "SPAN",
    "NET",
    nullptr
  };
  return names;
}

inline const char *EnumNameMarginMode(MarginMode e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMarginMode()[index];
}

struct Pair FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FIRST = 4,
    VT_SECOND = 6
  };
  const flatbuffers::String *first() const {
    return GetPointer<const flatbuffers::String *>(VT_FIRST);
  }
  const flatbuffers::String *second() const {
    return GetPointer<const flatbuffers::String *>(VT_SECOND);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FIRST) &&
           verifier.Verify(first()) &&
           VerifyOffset(verifier, VT_SECOND) &&
           verifier.Verify(second()) &&
           verifier.EndTable();
  }
};

struct PairBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_first(flatbuffers::Offset<flatbuffers::String> first) {
    fbb_.AddOffset(Pair::VT_FIRST, first);
  }
  void add_second(flatbuffers::Offset<flatbuffers::String> second) {
    fbb_.AddOffset(Pair::VT_SECOND, second);
  }
  explicit PairBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PairBuilder &operator=(const PairBuilder &);
  flatbuffers::Offset<Pair> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pair>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pair> CreatePair(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> first = 0,
    flatbuffers::Offset<flatbuffers::String> second = 0) {
  PairBuilder builder_(_fbb);
  builder_.add_second(second);
  builder_.add_first(first);
  return builder_.Finish();
}

inline flatbuffers::Offset<Pair> CreatePairDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *first = nullptr,
    const char *second = nullptr) {
  return mm::CreatePair(
      _fbb,
      first ? _fbb.CreateString(first) : 0,
      second ? _fbb.CreateString(second) : 0);
}

struct Result FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRCODE = 4,
    VT_ERRMSG = 6
  };
  const flatbuffers::String *errcode() const {
    return GetPointer<const flatbuffers::String *>(VT_ERRCODE);
  }
  const flatbuffers::String *errmsg() const {
    return GetPointer<const flatbuffers::String *>(VT_ERRMSG);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ERRCODE) &&
           verifier.Verify(errcode()) &&
           VerifyOffset(verifier, VT_ERRMSG) &&
           verifier.Verify(errmsg()) &&
           verifier.EndTable();
  }
};

struct ResultBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errcode(flatbuffers::Offset<flatbuffers::String> errcode) {
    fbb_.AddOffset(Result::VT_ERRCODE, errcode);
  }
  void add_errmsg(flatbuffers::Offset<flatbuffers::String> errmsg) {
    fbb_.AddOffset(Result::VT_ERRMSG, errmsg);
  }
  explicit ResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResultBuilder &operator=(const ResultBuilder &);
  flatbuffers::Offset<Result> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Result>(end);
    return o;
  }
};

inline flatbuffers::Offset<Result> CreateResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> errcode = 0,
    flatbuffers::Offset<flatbuffers::String> errmsg = 0) {
  ResultBuilder builder_(_fbb);
  builder_.add_errmsg(errmsg);
  builder_.add_errcode(errcode);
  return builder_.Finish();
}

inline flatbuffers::Offset<Result> CreateResultDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *errcode = nullptr,
    const char *errmsg = nullptr) {
  return mm::CreateResult(
      _fbb,
      errcode ? _fbb.CreateString(errcode) : 0,
      errmsg ? _fbb.CreateString(errmsg) : 0);
}

struct Bank FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BANKID = 4,
    VT_ENG_NAME = 6,
    VT_CHT_NAME = 8,
    VT_CHS_NAME = 10,
    VT_EXTRAS = 12
  };
  uint32_t bankid() const {
    return GetField<uint32_t>(VT_BANKID, 0);
  }
  const flatbuffers::String *eng_name() const {
    return GetPointer<const flatbuffers::String *>(VT_ENG_NAME);
  }
  const flatbuffers::String *cht_name() const {
    return GetPointer<const flatbuffers::String *>(VT_CHT_NAME);
  }
  const flatbuffers::String *chs_name() const {
    return GetPointer<const flatbuffers::String *>(VT_CHS_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_BANKID) &&
           VerifyOffset(verifier, VT_ENG_NAME) &&
           verifier.Verify(eng_name()) &&
           VerifyOffset(verifier, VT_CHT_NAME) &&
           verifier.Verify(cht_name()) &&
           VerifyOffset(verifier, VT_CHS_NAME) &&
           verifier.Verify(chs_name()) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           verifier.EndTable();
  }
};

struct BankBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bankid(uint32_t bankid) {
    fbb_.AddElement<uint32_t>(Bank::VT_BANKID, bankid, 0);
  }
  void add_eng_name(flatbuffers::Offset<flatbuffers::String> eng_name) {
    fbb_.AddOffset(Bank::VT_ENG_NAME, eng_name);
  }
  void add_cht_name(flatbuffers::Offset<flatbuffers::String> cht_name) {
    fbb_.AddOffset(Bank::VT_CHT_NAME, cht_name);
  }
  void add_chs_name(flatbuffers::Offset<flatbuffers::String> chs_name) {
    fbb_.AddOffset(Bank::VT_CHS_NAME, chs_name);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(Bank::VT_EXTRAS, extras);
  }
  explicit BankBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BankBuilder &operator=(const BankBuilder &);
  flatbuffers::Offset<Bank> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Bank>(end);
    return o;
  }
};

inline flatbuffers::Offset<Bank> CreateBank(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t bankid = 0,
    flatbuffers::Offset<flatbuffers::String> eng_name = 0,
    flatbuffers::Offset<flatbuffers::String> cht_name = 0,
    flatbuffers::Offset<flatbuffers::String> chs_name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0) {
  BankBuilder builder_(_fbb);
  builder_.add_extras(extras);
  builder_.add_chs_name(chs_name);
  builder_.add_cht_name(cht_name);
  builder_.add_eng_name(eng_name);
  builder_.add_bankid(bankid);
  return builder_.Finish();
}

inline flatbuffers::Offset<Bank> CreateBankDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t bankid = 0,
    const char *eng_name = nullptr,
    const char *cht_name = nullptr,
    const char *chs_name = nullptr,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr) {
  return mm::CreateBank(
      _fbb,
      bankid,
      eng_name ? _fbb.CreateString(eng_name) : 0,
      cht_name ? _fbb.CreateString(cht_name) : 0,
      chs_name ? _fbb.CreateString(chs_name) : 0,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0);
}

struct Banks FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMS = 4,
    VT_EXTRAS = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<Bank>> *items() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Bank>> *>(VT_ITEMS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.Verify(items()) &&
           verifier.VerifyVectorOfTables(items()) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           verifier.EndTable();
  }
};

struct BanksBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Bank>>> items) {
    fbb_.AddOffset(Banks::VT_ITEMS, items);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(Banks::VT_EXTRAS, extras);
  }
  explicit BanksBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BanksBuilder &operator=(const BanksBuilder &);
  flatbuffers::Offset<Banks> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Banks>(end);
    return o;
  }
};

inline flatbuffers::Offset<Banks> CreateBanks(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Bank>>> items = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0) {
  BanksBuilder builder_(_fbb);
  builder_.add_extras(extras);
  builder_.add_items(items);
  return builder_.Finish();
}

inline flatbuffers::Offset<Banks> CreateBanksDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Bank>> *items = nullptr,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr) {
  return mm::CreateBanks(
      _fbb,
      items ? _fbb.CreateVector<flatbuffers::Offset<Bank>>(*items) : 0,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0);
}

struct Account FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_USER = 4,
    VT_CLIENT_ACC = 6,
    VT_SESSION = 8,
    VT_UUID_3RD = 10,
    VT_MOBILE = 12,
    VT_EXTRAS = 14
  };
  const flatbuffers::String *user() const {
    return GetPointer<const flatbuffers::String *>(VT_USER);
  }
  const flatbuffers::String *client_acc() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENT_ACC);
  }
  const flatbuffers::String *session() const {
    return GetPointer<const flatbuffers::String *>(VT_SESSION);
  }
  const flatbuffers::String *uuid_3rd() const {
    return GetPointer<const flatbuffers::String *>(VT_UUID_3RD);
  }
  const flatbuffers::String *mobile() const {
    return GetPointer<const flatbuffers::String *>(VT_MOBILE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_USER) &&
           verifier.Verify(user()) &&
           VerifyOffset(verifier, VT_CLIENT_ACC) &&
           verifier.Verify(client_acc()) &&
           VerifyOffset(verifier, VT_SESSION) &&
           verifier.Verify(session()) &&
           VerifyOffset(verifier, VT_UUID_3RD) &&
           verifier.Verify(uuid_3rd()) &&
           VerifyOffset(verifier, VT_MOBILE) &&
           verifier.Verify(mobile()) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           verifier.EndTable();
  }
};

struct AccountBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_user(flatbuffers::Offset<flatbuffers::String> user) {
    fbb_.AddOffset(Account::VT_USER, user);
  }
  void add_client_acc(flatbuffers::Offset<flatbuffers::String> client_acc) {
    fbb_.AddOffset(Account::VT_CLIENT_ACC, client_acc);
  }
  void add_session(flatbuffers::Offset<flatbuffers::String> session) {
    fbb_.AddOffset(Account::VT_SESSION, session);
  }
  void add_uuid_3rd(flatbuffers::Offset<flatbuffers::String> uuid_3rd) {
    fbb_.AddOffset(Account::VT_UUID_3RD, uuid_3rd);
  }
  void add_mobile(flatbuffers::Offset<flatbuffers::String> mobile) {
    fbb_.AddOffset(Account::VT_MOBILE, mobile);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(Account::VT_EXTRAS, extras);
  }
  explicit AccountBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AccountBuilder &operator=(const AccountBuilder &);
  flatbuffers::Offset<Account> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Account>(end);
    return o;
  }
};

inline flatbuffers::Offset<Account> CreateAccount(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> user = 0,
    flatbuffers::Offset<flatbuffers::String> client_acc = 0,
    flatbuffers::Offset<flatbuffers::String> session = 0,
    flatbuffers::Offset<flatbuffers::String> uuid_3rd = 0,
    flatbuffers::Offset<flatbuffers::String> mobile = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0) {
  AccountBuilder builder_(_fbb);
  builder_.add_extras(extras);
  builder_.add_mobile(mobile);
  builder_.add_uuid_3rd(uuid_3rd);
  builder_.add_session(session);
  builder_.add_client_acc(client_acc);
  builder_.add_user(user);
  return builder_.Finish();
}

inline flatbuffers::Offset<Account> CreateAccountDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *user = nullptr,
    const char *client_acc = nullptr,
    const char *session = nullptr,
    const char *uuid_3rd = nullptr,
    const char *mobile = nullptr,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr) {
  return mm::CreateAccount(
      _fbb,
      user ? _fbb.CreateString(user) : 0,
      client_acc ? _fbb.CreateString(client_acc) : 0,
      session ? _fbb.CreateString(session) : 0,
      uuid_3rd ? _fbb.CreateString(uuid_3rd) : 0,
      mobile ? _fbb.CreateString(mobile) : 0,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0);
}

struct Query_page FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MODE = 4,
    VT_IDX = 6,
    VT_COUNT = 8
  };
  Page_mode mode() const {
    return static_cast<Page_mode>(GetField<uint8_t>(VT_MODE, 0));
  }
  uint32_t idx() const {
    return GetField<uint32_t>(VT_IDX, 0);
  }
  uint32_t count() const {
    return GetField<uint32_t>(VT_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MODE) &&
           VerifyField<uint32_t>(verifier, VT_IDX) &&
           VerifyField<uint32_t>(verifier, VT_COUNT) &&
           verifier.EndTable();
  }
};

struct Query_pageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mode(Page_mode mode) {
    fbb_.AddElement<uint8_t>(Query_page::VT_MODE, static_cast<uint8_t>(mode), 0);
  }
  void add_idx(uint32_t idx) {
    fbb_.AddElement<uint32_t>(Query_page::VT_IDX, idx, 0);
  }
  void add_count(uint32_t count) {
    fbb_.AddElement<uint32_t>(Query_page::VT_COUNT, count, 0);
  }
  explicit Query_pageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Query_pageBuilder &operator=(const Query_pageBuilder &);
  flatbuffers::Offset<Query_page> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Query_page>(end);
    return o;
  }
};

inline flatbuffers::Offset<Query_page> CreateQuery_page(
    flatbuffers::FlatBufferBuilder &_fbb,
    Page_mode mode = Page_mode_ALL,
    uint32_t idx = 0,
    uint32_t count = 0) {
  Query_pageBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_idx(idx);
  builder_.add_mode(mode);
  return builder_.Finish();
}

struct Deal_summary FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DEAL_DAY = 4,
    VT_ENTRUST_NO = 6,
    VT_DEAL_QTY = 8,
    VT_QUEUE_QTY = 10,
    VT_DEAL_PRICE = 12,
    VT_AMOUNT = 14,
    VT_STATUS = 16,
    VT_EXTRAS = 18
  };
  const flatbuffers::String *deal_day() const {
    return GetPointer<const flatbuffers::String *>(VT_DEAL_DAY);
  }
  const flatbuffers::String *entrust_no() const {
    return GetPointer<const flatbuffers::String *>(VT_ENTRUST_NO);
  }
  const flatbuffers::String *deal_qty() const {
    return GetPointer<const flatbuffers::String *>(VT_DEAL_QTY);
  }
  const flatbuffers::String *queue_qty() const {
    return GetPointer<const flatbuffers::String *>(VT_QUEUE_QTY);
  }
  const flatbuffers::String *deal_price() const {
    return GetPointer<const flatbuffers::String *>(VT_DEAL_PRICE);
  }
  const flatbuffers::String *amount() const {
    return GetPointer<const flatbuffers::String *>(VT_AMOUNT);
  }
  Entrust_status status() const {
    return static_cast<Entrust_status>(GetField<uint8_t>(VT_STATUS, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DEAL_DAY) &&
           verifier.Verify(deal_day()) &&
           VerifyOffset(verifier, VT_ENTRUST_NO) &&
           verifier.Verify(entrust_no()) &&
           VerifyOffset(verifier, VT_DEAL_QTY) &&
           verifier.Verify(deal_qty()) &&
           VerifyOffset(verifier, VT_QUEUE_QTY) &&
           verifier.Verify(queue_qty()) &&
           VerifyOffset(verifier, VT_DEAL_PRICE) &&
           verifier.Verify(deal_price()) &&
           VerifyOffset(verifier, VT_AMOUNT) &&
           verifier.Verify(amount()) &&
           VerifyField<uint8_t>(verifier, VT_STATUS) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           verifier.EndTable();
  }
};

struct Deal_summaryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_deal_day(flatbuffers::Offset<flatbuffers::String> deal_day) {
    fbb_.AddOffset(Deal_summary::VT_DEAL_DAY, deal_day);
  }
  void add_entrust_no(flatbuffers::Offset<flatbuffers::String> entrust_no) {
    fbb_.AddOffset(Deal_summary::VT_ENTRUST_NO, entrust_no);
  }
  void add_deal_qty(flatbuffers::Offset<flatbuffers::String> deal_qty) {
    fbb_.AddOffset(Deal_summary::VT_DEAL_QTY, deal_qty);
  }
  void add_queue_qty(flatbuffers::Offset<flatbuffers::String> queue_qty) {
    fbb_.AddOffset(Deal_summary::VT_QUEUE_QTY, queue_qty);
  }
  void add_deal_price(flatbuffers::Offset<flatbuffers::String> deal_price) {
    fbb_.AddOffset(Deal_summary::VT_DEAL_PRICE, deal_price);
  }
  void add_amount(flatbuffers::Offset<flatbuffers::String> amount) {
    fbb_.AddOffset(Deal_summary::VT_AMOUNT, amount);
  }
  void add_status(Entrust_status status) {
    fbb_.AddElement<uint8_t>(Deal_summary::VT_STATUS, static_cast<uint8_t>(status), 0);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(Deal_summary::VT_EXTRAS, extras);
  }
  explicit Deal_summaryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Deal_summaryBuilder &operator=(const Deal_summaryBuilder &);
  flatbuffers::Offset<Deal_summary> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Deal_summary>(end);
    return o;
  }
};

inline flatbuffers::Offset<Deal_summary> CreateDeal_summary(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> deal_day = 0,
    flatbuffers::Offset<flatbuffers::String> entrust_no = 0,
    flatbuffers::Offset<flatbuffers::String> deal_qty = 0,
    flatbuffers::Offset<flatbuffers::String> queue_qty = 0,
    flatbuffers::Offset<flatbuffers::String> deal_price = 0,
    flatbuffers::Offset<flatbuffers::String> amount = 0,
    Entrust_status status = Entrust_status_NONE,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0) {
  Deal_summaryBuilder builder_(_fbb);
  builder_.add_extras(extras);
  builder_.add_amount(amount);
  builder_.add_deal_price(deal_price);
  builder_.add_queue_qty(queue_qty);
  builder_.add_deal_qty(deal_qty);
  builder_.add_entrust_no(entrust_no);
  builder_.add_deal_day(deal_day);
  builder_.add_status(status);
  return builder_.Finish();
}

inline flatbuffers::Offset<Deal_summary> CreateDeal_summaryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *deal_day = nullptr,
    const char *entrust_no = nullptr,
    const char *deal_qty = nullptr,
    const char *queue_qty = nullptr,
    const char *deal_price = nullptr,
    const char *amount = nullptr,
    Entrust_status status = Entrust_status_NONE,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr) {
  return mm::CreateDeal_summary(
      _fbb,
      deal_day ? _fbb.CreateString(deal_day) : 0,
      entrust_no ? _fbb.CreateString(entrust_no) : 0,
      deal_qty ? _fbb.CreateString(deal_qty) : 0,
      queue_qty ? _fbb.CreateString(queue_qty) : 0,
      deal_price ? _fbb.CreateString(deal_price) : 0,
      amount ? _fbb.CreateString(amount) : 0,
      status,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0);
}

struct Deal_detail FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACC = 4,
    VT_DEAL_TIME = 6,
    VT_ENTRUST_NO = 8,
    VT_MARKET = 10,
    VT_SYMBOL = 12,
    VT_BARGAIN_NO = 14,
    VT_DIRECTION = 16,
    VT_PRICE = 18,
    VT_DEAL_QTY = 20,
    VT_QUEUE_QTY = 22,
    VT_OPPONENT_ENTRUST_NO = 24,
    VT_COMMISSION = 26,
    VT_CHARGE = 28,
    VT_EXTRAS = 30
  };
  const Account *acc() const {
    return GetPointer<const Account *>(VT_ACC);
  }
  const flatbuffers::String *deal_time() const {
    return GetPointer<const flatbuffers::String *>(VT_DEAL_TIME);
  }
  const flatbuffers::String *entrust_no() const {
    return GetPointer<const flatbuffers::String *>(VT_ENTRUST_NO);
  }
  Market market() const {
    return static_cast<Market>(GetField<uint8_t>(VT_MARKET, 0));
  }
  const flatbuffers::String *symbol() const {
    return GetPointer<const flatbuffers::String *>(VT_SYMBOL);
  }
  const flatbuffers::String *bargain_no() const {
    return GetPointer<const flatbuffers::String *>(VT_BARGAIN_NO);
  }
  Entrust_mode direction() const {
    return static_cast<Entrust_mode>(GetField<uint8_t>(VT_DIRECTION, 0));
  }
  const flatbuffers::String *price() const {
    return GetPointer<const flatbuffers::String *>(VT_PRICE);
  }
  const flatbuffers::String *deal_qty() const {
    return GetPointer<const flatbuffers::String *>(VT_DEAL_QTY);
  }
  const flatbuffers::String *queue_qty() const {
    return GetPointer<const flatbuffers::String *>(VT_QUEUE_QTY);
  }
  const flatbuffers::String *opponent_entrust_no() const {
    return GetPointer<const flatbuffers::String *>(VT_OPPONENT_ENTRUST_NO);
  }
  const flatbuffers::String *commission() const {
    return GetPointer<const flatbuffers::String *>(VT_COMMISSION);
  }
  const flatbuffers::String *charge() const {
    return GetPointer<const flatbuffers::String *>(VT_CHARGE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACC) &&
           verifier.VerifyTable(acc()) &&
           VerifyOffset(verifier, VT_DEAL_TIME) &&
           verifier.Verify(deal_time()) &&
           VerifyOffset(verifier, VT_ENTRUST_NO) &&
           verifier.Verify(entrust_no()) &&
           VerifyField<uint8_t>(verifier, VT_MARKET) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.Verify(symbol()) &&
           VerifyOffset(verifier, VT_BARGAIN_NO) &&
           verifier.Verify(bargain_no()) &&
           VerifyField<uint8_t>(verifier, VT_DIRECTION) &&
           VerifyOffset(verifier, VT_PRICE) &&
           verifier.Verify(price()) &&
           VerifyOffset(verifier, VT_DEAL_QTY) &&
           verifier.Verify(deal_qty()) &&
           VerifyOffset(verifier, VT_QUEUE_QTY) &&
           verifier.Verify(queue_qty()) &&
           VerifyOffset(verifier, VT_OPPONENT_ENTRUST_NO) &&
           verifier.Verify(opponent_entrust_no()) &&
           VerifyOffset(verifier, VT_COMMISSION) &&
           verifier.Verify(commission()) &&
           VerifyOffset(verifier, VT_CHARGE) &&
           verifier.Verify(charge()) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           verifier.EndTable();
  }
};

struct Deal_detailBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acc(flatbuffers::Offset<Account> acc) {
    fbb_.AddOffset(Deal_detail::VT_ACC, acc);
  }
  void add_deal_time(flatbuffers::Offset<flatbuffers::String> deal_time) {
    fbb_.AddOffset(Deal_detail::VT_DEAL_TIME, deal_time);
  }
  void add_entrust_no(flatbuffers::Offset<flatbuffers::String> entrust_no) {
    fbb_.AddOffset(Deal_detail::VT_ENTRUST_NO, entrust_no);
  }
  void add_market(Market market) {
    fbb_.AddElement<uint8_t>(Deal_detail::VT_MARKET, static_cast<uint8_t>(market), 0);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) {
    fbb_.AddOffset(Deal_detail::VT_SYMBOL, symbol);
  }
  void add_bargain_no(flatbuffers::Offset<flatbuffers::String> bargain_no) {
    fbb_.AddOffset(Deal_detail::VT_BARGAIN_NO, bargain_no);
  }
  void add_direction(Entrust_mode direction) {
    fbb_.AddElement<uint8_t>(Deal_detail::VT_DIRECTION, static_cast<uint8_t>(direction), 0);
  }
  void add_price(flatbuffers::Offset<flatbuffers::String> price) {
    fbb_.AddOffset(Deal_detail::VT_PRICE, price);
  }
  void add_deal_qty(flatbuffers::Offset<flatbuffers::String> deal_qty) {
    fbb_.AddOffset(Deal_detail::VT_DEAL_QTY, deal_qty);
  }
  void add_queue_qty(flatbuffers::Offset<flatbuffers::String> queue_qty) {
    fbb_.AddOffset(Deal_detail::VT_QUEUE_QTY, queue_qty);
  }
  void add_opponent_entrust_no(flatbuffers::Offset<flatbuffers::String> opponent_entrust_no) {
    fbb_.AddOffset(Deal_detail::VT_OPPONENT_ENTRUST_NO, opponent_entrust_no);
  }
  void add_commission(flatbuffers::Offset<flatbuffers::String> commission) {
    fbb_.AddOffset(Deal_detail::VT_COMMISSION, commission);
  }
  void add_charge(flatbuffers::Offset<flatbuffers::String> charge) {
    fbb_.AddOffset(Deal_detail::VT_CHARGE, charge);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(Deal_detail::VT_EXTRAS, extras);
  }
  explicit Deal_detailBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Deal_detailBuilder &operator=(const Deal_detailBuilder &);
  flatbuffers::Offset<Deal_detail> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Deal_detail>(end);
    return o;
  }
};

inline flatbuffers::Offset<Deal_detail> CreateDeal_detail(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    flatbuffers::Offset<flatbuffers::String> deal_time = 0,
    flatbuffers::Offset<flatbuffers::String> entrust_no = 0,
    Market market = Market_NONE,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    flatbuffers::Offset<flatbuffers::String> bargain_no = 0,
    Entrust_mode direction = Entrust_mode_NONE,
    flatbuffers::Offset<flatbuffers::String> price = 0,
    flatbuffers::Offset<flatbuffers::String> deal_qty = 0,
    flatbuffers::Offset<flatbuffers::String> queue_qty = 0,
    flatbuffers::Offset<flatbuffers::String> opponent_entrust_no = 0,
    flatbuffers::Offset<flatbuffers::String> commission = 0,
    flatbuffers::Offset<flatbuffers::String> charge = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0) {
  Deal_detailBuilder builder_(_fbb);
  builder_.add_extras(extras);
  builder_.add_charge(charge);
  builder_.add_commission(commission);
  builder_.add_opponent_entrust_no(opponent_entrust_no);
  builder_.add_queue_qty(queue_qty);
  builder_.add_deal_qty(deal_qty);
  builder_.add_price(price);
  builder_.add_bargain_no(bargain_no);
  builder_.add_symbol(symbol);
  builder_.add_entrust_no(entrust_no);
  builder_.add_deal_time(deal_time);
  builder_.add_acc(acc);
  builder_.add_direction(direction);
  builder_.add_market(market);
  return builder_.Finish();
}

inline flatbuffers::Offset<Deal_detail> CreateDeal_detailDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    const char *deal_time = nullptr,
    const char *entrust_no = nullptr,
    Market market = Market_NONE,
    const char *symbol = nullptr,
    const char *bargain_no = nullptr,
    Entrust_mode direction = Entrust_mode_NONE,
    const char *price = nullptr,
    const char *deal_qty = nullptr,
    const char *queue_qty = nullptr,
    const char *opponent_entrust_no = nullptr,
    const char *commission = nullptr,
    const char *charge = nullptr,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr) {
  return mm::CreateDeal_detail(
      _fbb,
      acc,
      deal_time ? _fbb.CreateString(deal_time) : 0,
      entrust_no ? _fbb.CreateString(entrust_no) : 0,
      market,
      symbol ? _fbb.CreateString(symbol) : 0,
      bargain_no ? _fbb.CreateString(bargain_no) : 0,
      direction,
      price ? _fbb.CreateString(price) : 0,
      deal_qty ? _fbb.CreateString(deal_qty) : 0,
      queue_qty ? _fbb.CreateString(queue_qty) : 0,
      opponent_entrust_no ? _fbb.CreateString(opponent_entrust_no) : 0,
      commission ? _fbb.CreateString(commission) : 0,
      charge ? _fbb.CreateString(charge) : 0,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0);
}

struct Capital_detail FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACC = 4,
    VT_TIME = 6,
    VT_SERIALNO = 8,
    VT_BUSINESS_TYPE = 10,
    VT_MEDIA_TYPE = 12,
    VT_BANKID = 14,
    VT_AMOUNT = 16,
    VT_CCY = 18,
    VT_EXTRAS = 20
  };
  const Account *acc() const {
    return GetPointer<const Account *>(VT_ACC);
  }
  const flatbuffers::String *time() const {
    return GetPointer<const flatbuffers::String *>(VT_TIME);
  }
  const flatbuffers::String *serialno() const {
    return GetPointer<const flatbuffers::String *>(VT_SERIALNO);
  }
  CashIOType business_type() const {
    return static_cast<CashIOType>(GetField<uint8_t>(VT_BUSINESS_TYPE, 0));
  }
  CashMedia media_type() const {
    return static_cast<CashMedia>(GetField<uint8_t>(VT_MEDIA_TYPE, 0));
  }
  const Bank *bankid() const {
    return GetPointer<const Bank *>(VT_BANKID);
  }
  const flatbuffers::String *amount() const {
    return GetPointer<const flatbuffers::String *>(VT_AMOUNT);
  }
  Currency ccy() const {
    return static_cast<Currency>(GetField<uint8_t>(VT_CCY, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACC) &&
           verifier.VerifyTable(acc()) &&
           VerifyOffset(verifier, VT_TIME) &&
           verifier.Verify(time()) &&
           VerifyOffset(verifier, VT_SERIALNO) &&
           verifier.Verify(serialno()) &&
           VerifyField<uint8_t>(verifier, VT_BUSINESS_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_MEDIA_TYPE) &&
           VerifyOffset(verifier, VT_BANKID) &&
           verifier.VerifyTable(bankid()) &&
           VerifyOffset(verifier, VT_AMOUNT) &&
           verifier.Verify(amount()) &&
           VerifyField<uint8_t>(verifier, VT_CCY) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           verifier.EndTable();
  }
};

struct Capital_detailBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acc(flatbuffers::Offset<Account> acc) {
    fbb_.AddOffset(Capital_detail::VT_ACC, acc);
  }
  void add_time(flatbuffers::Offset<flatbuffers::String> time) {
    fbb_.AddOffset(Capital_detail::VT_TIME, time);
  }
  void add_serialno(flatbuffers::Offset<flatbuffers::String> serialno) {
    fbb_.AddOffset(Capital_detail::VT_SERIALNO, serialno);
  }
  void add_business_type(CashIOType business_type) {
    fbb_.AddElement<uint8_t>(Capital_detail::VT_BUSINESS_TYPE, static_cast<uint8_t>(business_type), 0);
  }
  void add_media_type(CashMedia media_type) {
    fbb_.AddElement<uint8_t>(Capital_detail::VT_MEDIA_TYPE, static_cast<uint8_t>(media_type), 0);
  }
  void add_bankid(flatbuffers::Offset<Bank> bankid) {
    fbb_.AddOffset(Capital_detail::VT_BANKID, bankid);
  }
  void add_amount(flatbuffers::Offset<flatbuffers::String> amount) {
    fbb_.AddOffset(Capital_detail::VT_AMOUNT, amount);
  }
  void add_ccy(Currency ccy) {
    fbb_.AddElement<uint8_t>(Capital_detail::VT_CCY, static_cast<uint8_t>(ccy), 0);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(Capital_detail::VT_EXTRAS, extras);
  }
  explicit Capital_detailBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Capital_detailBuilder &operator=(const Capital_detailBuilder &);
  flatbuffers::Offset<Capital_detail> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Capital_detail>(end);
    return o;
  }
};

inline flatbuffers::Offset<Capital_detail> CreateCapital_detail(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    flatbuffers::Offset<flatbuffers::String> time = 0,
    flatbuffers::Offset<flatbuffers::String> serialno = 0,
    CashIOType business_type = CashIOType_NONE,
    CashMedia media_type = CashMedia_NONE,
    flatbuffers::Offset<Bank> bankid = 0,
    flatbuffers::Offset<flatbuffers::String> amount = 0,
    Currency ccy = Currency_NONE,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0) {
  Capital_detailBuilder builder_(_fbb);
  builder_.add_extras(extras);
  builder_.add_amount(amount);
  builder_.add_bankid(bankid);
  builder_.add_serialno(serialno);
  builder_.add_time(time);
  builder_.add_acc(acc);
  builder_.add_ccy(ccy);
  builder_.add_media_type(media_type);
  builder_.add_business_type(business_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Capital_detail> CreateCapital_detailDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    const char *time = nullptr,
    const char *serialno = nullptr,
    CashIOType business_type = CashIOType_NONE,
    CashMedia media_type = CashMedia_NONE,
    flatbuffers::Offset<Bank> bankid = 0,
    const char *amount = nullptr,
    Currency ccy = Currency_NONE,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr) {
  return mm::CreateCapital_detail(
      _fbb,
      acc,
      time ? _fbb.CreateString(time) : 0,
      serialno ? _fbb.CreateString(serialno) : 0,
      business_type,
      media_type,
      bankid,
      amount ? _fbb.CreateString(amount) : 0,
      ccy,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0);
}

struct Fee FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CCASS = 4,
    VT_COMMISSION = 6,
    VT_STAMP = 8,
    VT_LEVY = 10,
    VT_CHARGE = 12,
    VT_TRADEVALUE = 14,
    VT_OTHER = 16,
    VT_TARIFF = 18,
    VT_EXTRAS = 20
  };
  const flatbuffers::String *ccass() const {
    return GetPointer<const flatbuffers::String *>(VT_CCASS);
  }
  const flatbuffers::String *commission() const {
    return GetPointer<const flatbuffers::String *>(VT_COMMISSION);
  }
  const flatbuffers::String *stamp() const {
    return GetPointer<const flatbuffers::String *>(VT_STAMP);
  }
  const flatbuffers::String *levy() const {
    return GetPointer<const flatbuffers::String *>(VT_LEVY);
  }
  const flatbuffers::String *charge() const {
    return GetPointer<const flatbuffers::String *>(VT_CHARGE);
  }
  const flatbuffers::String *tradevalue() const {
    return GetPointer<const flatbuffers::String *>(VT_TRADEVALUE);
  }
  const flatbuffers::String *other() const {
    return GetPointer<const flatbuffers::String *>(VT_OTHER);
  }
  const flatbuffers::String *tariff() const {
    return GetPointer<const flatbuffers::String *>(VT_TARIFF);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CCASS) &&
           verifier.Verify(ccass()) &&
           VerifyOffset(verifier, VT_COMMISSION) &&
           verifier.Verify(commission()) &&
           VerifyOffset(verifier, VT_STAMP) &&
           verifier.Verify(stamp()) &&
           VerifyOffset(verifier, VT_LEVY) &&
           verifier.Verify(levy()) &&
           VerifyOffset(verifier, VT_CHARGE) &&
           verifier.Verify(charge()) &&
           VerifyOffset(verifier, VT_TRADEVALUE) &&
           verifier.Verify(tradevalue()) &&
           VerifyOffset(verifier, VT_OTHER) &&
           verifier.Verify(other()) &&
           VerifyOffset(verifier, VT_TARIFF) &&
           verifier.Verify(tariff()) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           verifier.EndTable();
  }
};

struct FeeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ccass(flatbuffers::Offset<flatbuffers::String> ccass) {
    fbb_.AddOffset(Fee::VT_CCASS, ccass);
  }
  void add_commission(flatbuffers::Offset<flatbuffers::String> commission) {
    fbb_.AddOffset(Fee::VT_COMMISSION, commission);
  }
  void add_stamp(flatbuffers::Offset<flatbuffers::String> stamp) {
    fbb_.AddOffset(Fee::VT_STAMP, stamp);
  }
  void add_levy(flatbuffers::Offset<flatbuffers::String> levy) {
    fbb_.AddOffset(Fee::VT_LEVY, levy);
  }
  void add_charge(flatbuffers::Offset<flatbuffers::String> charge) {
    fbb_.AddOffset(Fee::VT_CHARGE, charge);
  }
  void add_tradevalue(flatbuffers::Offset<flatbuffers::String> tradevalue) {
    fbb_.AddOffset(Fee::VT_TRADEVALUE, tradevalue);
  }
  void add_other(flatbuffers::Offset<flatbuffers::String> other) {
    fbb_.AddOffset(Fee::VT_OTHER, other);
  }
  void add_tariff(flatbuffers::Offset<flatbuffers::String> tariff) {
    fbb_.AddOffset(Fee::VT_TARIFF, tariff);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(Fee::VT_EXTRAS, extras);
  }
  explicit FeeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FeeBuilder &operator=(const FeeBuilder &);
  flatbuffers::Offset<Fee> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Fee>(end);
    return o;
  }
};

inline flatbuffers::Offset<Fee> CreateFee(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> ccass = 0,
    flatbuffers::Offset<flatbuffers::String> commission = 0,
    flatbuffers::Offset<flatbuffers::String> stamp = 0,
    flatbuffers::Offset<flatbuffers::String> levy = 0,
    flatbuffers::Offset<flatbuffers::String> charge = 0,
    flatbuffers::Offset<flatbuffers::String> tradevalue = 0,
    flatbuffers::Offset<flatbuffers::String> other = 0,
    flatbuffers::Offset<flatbuffers::String> tariff = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0) {
  FeeBuilder builder_(_fbb);
  builder_.add_extras(extras);
  builder_.add_tariff(tariff);
  builder_.add_other(other);
  builder_.add_tradevalue(tradevalue);
  builder_.add_charge(charge);
  builder_.add_levy(levy);
  builder_.add_stamp(stamp);
  builder_.add_commission(commission);
  builder_.add_ccass(ccass);
  return builder_.Finish();
}

inline flatbuffers::Offset<Fee> CreateFeeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *ccass = nullptr,
    const char *commission = nullptr,
    const char *stamp = nullptr,
    const char *levy = nullptr,
    const char *charge = nullptr,
    const char *tradevalue = nullptr,
    const char *other = nullptr,
    const char *tariff = nullptr,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr) {
  return mm::CreateFee(
      _fbb,
      ccass ? _fbb.CreateString(ccass) : 0,
      commission ? _fbb.CreateString(commission) : 0,
      stamp ? _fbb.CreateString(stamp) : 0,
      levy ? _fbb.CreateString(levy) : 0,
      charge ? _fbb.CreateString(charge) : 0,
      tradevalue ? _fbb.CreateString(tradevalue) : 0,
      other ? _fbb.CreateString(other) : 0,
      tariff ? _fbb.CreateString(tariff) : 0,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0);
}

struct Entrust FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACC = 4,
    VT_MARKET = 6,
    VT_SYMBOL = 8,
    VT_ORDER_TIME = 10,
    VT_CCY = 12,
    VT_DIRECTION = 14,
    VT_PRICE_MODE = 16,
    VT_DEAL_MODE = 18,
    VT_PRICE = 20,
    VT_QTY = 22,
    VT_DEAL_QTY = 24,
    VT_OS_QTY = 26,
    VT_ENTRUST_NO = 28,
    VT_RELATED_ENTRUST_NO = 30,
    VT_STATUS = 32,
    VT_LOAN_RATIO = 34,
    VT_INPUT_CHANNEL = 36,
    VT_EXTRAS = 38,
    VT_DEAL = 40,
    VT_FEE = 42,
    VT_SPEC_COND = 44,
    VT_UPDATE_TIME = 46,
    VT_T_1 = 48,
    VT_SUB_STATUS = 50
  };
  const Account *acc() const {
    return GetPointer<const Account *>(VT_ACC);
  }
  Market market() const {
    return static_cast<Market>(GetField<uint8_t>(VT_MARKET, 0));
  }
  const flatbuffers::String *symbol() const {
    return GetPointer<const flatbuffers::String *>(VT_SYMBOL);
  }
  const flatbuffers::String *order_time() const {
    return GetPointer<const flatbuffers::String *>(VT_ORDER_TIME);
  }
  Currency ccy() const {
    return static_cast<Currency>(GetField<uint8_t>(VT_CCY, 0));
  }
  Entrust_mode direction() const {
    return static_cast<Entrust_mode>(GetField<uint8_t>(VT_DIRECTION, 0));
  }
  Price_mode price_mode() const {
    return static_cast<Price_mode>(GetField<uint8_t>(VT_PRICE_MODE, 0));
  }
  Deal_mode deal_mode() const {
    return static_cast<Deal_mode>(GetField<uint8_t>(VT_DEAL_MODE, 0));
  }
  const flatbuffers::String *price() const {
    return GetPointer<const flatbuffers::String *>(VT_PRICE);
  }
  const flatbuffers::String *qty() const {
    return GetPointer<const flatbuffers::String *>(VT_QTY);
  }
  const flatbuffers::String *deal_qty() const {
    return GetPointer<const flatbuffers::String *>(VT_DEAL_QTY);
  }
  const flatbuffers::String *os_qty() const {
    return GetPointer<const flatbuffers::String *>(VT_OS_QTY);
  }
  const flatbuffers::String *entrust_no() const {
    return GetPointer<const flatbuffers::String *>(VT_ENTRUST_NO);
  }
  const flatbuffers::String *related_entrust_no() const {
    return GetPointer<const flatbuffers::String *>(VT_RELATED_ENTRUST_NO);
  }
  Entrust_status status() const {
    return static_cast<Entrust_status>(GetField<uint8_t>(VT_STATUS, 0));
  }
  uint16_t loan_ratio() const {
    return GetField<uint16_t>(VT_LOAN_RATIO, 0);
  }
  TerminalType input_channel() const {
    return static_cast<TerminalType>(GetField<uint8_t>(VT_INPUT_CHANNEL, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  const Deal_summary *deal() const {
    return GetPointer<const Deal_summary *>(VT_DEAL);
  }
  const Fee *fee() const {
    return GetPointer<const Fee *>(VT_FEE);
  }
  const SpecialCond *spec_cond() const {
    return GetPointer<const SpecialCond *>(VT_SPEC_COND);
  }
  const flatbuffers::String *update_time() const {
    return GetPointer<const flatbuffers::String *>(VT_UPDATE_TIME);
  }
  bool T_1() const {
    return GetField<uint8_t>(VT_T_1, 0) != 0;
  }
  const flatbuffers::String *sub_status() const {
    return GetPointer<const flatbuffers::String *>(VT_SUB_STATUS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACC) &&
           verifier.VerifyTable(acc()) &&
           VerifyField<uint8_t>(verifier, VT_MARKET) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.Verify(symbol()) &&
           VerifyOffset(verifier, VT_ORDER_TIME) &&
           verifier.Verify(order_time()) &&
           VerifyField<uint8_t>(verifier, VT_CCY) &&
           VerifyField<uint8_t>(verifier, VT_DIRECTION) &&
           VerifyField<uint8_t>(verifier, VT_PRICE_MODE) &&
           VerifyField<uint8_t>(verifier, VT_DEAL_MODE) &&
           VerifyOffset(verifier, VT_PRICE) &&
           verifier.Verify(price()) &&
           VerifyOffset(verifier, VT_QTY) &&
           verifier.Verify(qty()) &&
           VerifyOffset(verifier, VT_DEAL_QTY) &&
           verifier.Verify(deal_qty()) &&
           VerifyOffset(verifier, VT_OS_QTY) &&
           verifier.Verify(os_qty()) &&
           VerifyOffset(verifier, VT_ENTRUST_NO) &&
           verifier.Verify(entrust_no()) &&
           VerifyOffset(verifier, VT_RELATED_ENTRUST_NO) &&
           verifier.Verify(related_entrust_no()) &&
           VerifyField<uint8_t>(verifier, VT_STATUS) &&
           VerifyField<uint16_t>(verifier, VT_LOAN_RATIO) &&
           VerifyField<uint8_t>(verifier, VT_INPUT_CHANNEL) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           VerifyOffset(verifier, VT_DEAL) &&
           verifier.VerifyTable(deal()) &&
           VerifyOffset(verifier, VT_FEE) &&
           verifier.VerifyTable(fee()) &&
           VerifyOffset(verifier, VT_SPEC_COND) &&
           verifier.VerifyTable(spec_cond()) &&
           VerifyOffset(verifier, VT_UPDATE_TIME) &&
           verifier.Verify(update_time()) &&
           VerifyField<uint8_t>(verifier, VT_T_1) &&
           VerifyOffset(verifier, VT_SUB_STATUS) &&
           verifier.Verify(sub_status()) &&
           verifier.EndTable();
  }
};

struct EntrustBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acc(flatbuffers::Offset<Account> acc) {
    fbb_.AddOffset(Entrust::VT_ACC, acc);
  }
  void add_market(Market market) {
    fbb_.AddElement<uint8_t>(Entrust::VT_MARKET, static_cast<uint8_t>(market), 0);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) {
    fbb_.AddOffset(Entrust::VT_SYMBOL, symbol);
  }
  void add_order_time(flatbuffers::Offset<flatbuffers::String> order_time) {
    fbb_.AddOffset(Entrust::VT_ORDER_TIME, order_time);
  }
  void add_ccy(Currency ccy) {
    fbb_.AddElement<uint8_t>(Entrust::VT_CCY, static_cast<uint8_t>(ccy), 0);
  }
  void add_direction(Entrust_mode direction) {
    fbb_.AddElement<uint8_t>(Entrust::VT_DIRECTION, static_cast<uint8_t>(direction), 0);
  }
  void add_price_mode(Price_mode price_mode) {
    fbb_.AddElement<uint8_t>(Entrust::VT_PRICE_MODE, static_cast<uint8_t>(price_mode), 0);
  }
  void add_deal_mode(Deal_mode deal_mode) {
    fbb_.AddElement<uint8_t>(Entrust::VT_DEAL_MODE, static_cast<uint8_t>(deal_mode), 0);
  }
  void add_price(flatbuffers::Offset<flatbuffers::String> price) {
    fbb_.AddOffset(Entrust::VT_PRICE, price);
  }
  void add_qty(flatbuffers::Offset<flatbuffers::String> qty) {
    fbb_.AddOffset(Entrust::VT_QTY, qty);
  }
  void add_deal_qty(flatbuffers::Offset<flatbuffers::String> deal_qty) {
    fbb_.AddOffset(Entrust::VT_DEAL_QTY, deal_qty);
  }
  void add_os_qty(flatbuffers::Offset<flatbuffers::String> os_qty) {
    fbb_.AddOffset(Entrust::VT_OS_QTY, os_qty);
  }
  void add_entrust_no(flatbuffers::Offset<flatbuffers::String> entrust_no) {
    fbb_.AddOffset(Entrust::VT_ENTRUST_NO, entrust_no);
  }
  void add_related_entrust_no(flatbuffers::Offset<flatbuffers::String> related_entrust_no) {
    fbb_.AddOffset(Entrust::VT_RELATED_ENTRUST_NO, related_entrust_no);
  }
  void add_status(Entrust_status status) {
    fbb_.AddElement<uint8_t>(Entrust::VT_STATUS, static_cast<uint8_t>(status), 0);
  }
  void add_loan_ratio(uint16_t loan_ratio) {
    fbb_.AddElement<uint16_t>(Entrust::VT_LOAN_RATIO, loan_ratio, 0);
  }
  void add_input_channel(TerminalType input_channel) {
    fbb_.AddElement<uint8_t>(Entrust::VT_INPUT_CHANNEL, static_cast<uint8_t>(input_channel), 0);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(Entrust::VT_EXTRAS, extras);
  }
  void add_deal(flatbuffers::Offset<Deal_summary> deal) {
    fbb_.AddOffset(Entrust::VT_DEAL, deal);
  }
  void add_fee(flatbuffers::Offset<Fee> fee) {
    fbb_.AddOffset(Entrust::VT_FEE, fee);
  }
  void add_spec_cond(flatbuffers::Offset<SpecialCond> spec_cond) {
    fbb_.AddOffset(Entrust::VT_SPEC_COND, spec_cond);
  }
  void add_update_time(flatbuffers::Offset<flatbuffers::String> update_time) {
    fbb_.AddOffset(Entrust::VT_UPDATE_TIME, update_time);
  }
  void add_T_1(bool T_1) {
    fbb_.AddElement<uint8_t>(Entrust::VT_T_1, static_cast<uint8_t>(T_1), 0);
  }
  void add_sub_status(flatbuffers::Offset<flatbuffers::String> sub_status) {
    fbb_.AddOffset(Entrust::VT_SUB_STATUS, sub_status);
  }
  explicit EntrustBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EntrustBuilder &operator=(const EntrustBuilder &);
  flatbuffers::Offset<Entrust> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Entrust>(end);
    return o;
  }
};

inline flatbuffers::Offset<Entrust> CreateEntrust(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    Market market = Market_NONE,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    flatbuffers::Offset<flatbuffers::String> order_time = 0,
    Currency ccy = Currency_NONE,
    Entrust_mode direction = Entrust_mode_NONE,
    Price_mode price_mode = Price_mode_NONE,
    Deal_mode deal_mode = Deal_mode_NONE,
    flatbuffers::Offset<flatbuffers::String> price = 0,
    flatbuffers::Offset<flatbuffers::String> qty = 0,
    flatbuffers::Offset<flatbuffers::String> deal_qty = 0,
    flatbuffers::Offset<flatbuffers::String> os_qty = 0,
    flatbuffers::Offset<flatbuffers::String> entrust_no = 0,
    flatbuffers::Offset<flatbuffers::String> related_entrust_no = 0,
    Entrust_status status = Entrust_status_NONE,
    uint16_t loan_ratio = 0,
    TerminalType input_channel = TerminalType_NONE,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0,
    flatbuffers::Offset<Deal_summary> deal = 0,
    flatbuffers::Offset<Fee> fee = 0,
    flatbuffers::Offset<SpecialCond> spec_cond = 0,
    flatbuffers::Offset<flatbuffers::String> update_time = 0,
    bool T_1 = false,
    flatbuffers::Offset<flatbuffers::String> sub_status = 0) {
  EntrustBuilder builder_(_fbb);
  builder_.add_sub_status(sub_status);
  builder_.add_update_time(update_time);
  builder_.add_spec_cond(spec_cond);
  builder_.add_fee(fee);
  builder_.add_deal(deal);
  builder_.add_extras(extras);
  builder_.add_related_entrust_no(related_entrust_no);
  builder_.add_entrust_no(entrust_no);
  builder_.add_os_qty(os_qty);
  builder_.add_deal_qty(deal_qty);
  builder_.add_qty(qty);
  builder_.add_price(price);
  builder_.add_order_time(order_time);
  builder_.add_symbol(symbol);
  builder_.add_acc(acc);
  builder_.add_loan_ratio(loan_ratio);
  builder_.add_T_1(T_1);
  builder_.add_input_channel(input_channel);
  builder_.add_status(status);
  builder_.add_deal_mode(deal_mode);
  builder_.add_price_mode(price_mode);
  builder_.add_direction(direction);
  builder_.add_ccy(ccy);
  builder_.add_market(market);
  return builder_.Finish();
}

inline flatbuffers::Offset<Entrust> CreateEntrustDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    Market market = Market_NONE,
    const char *symbol = nullptr,
    const char *order_time = nullptr,
    Currency ccy = Currency_NONE,
    Entrust_mode direction = Entrust_mode_NONE,
    Price_mode price_mode = Price_mode_NONE,
    Deal_mode deal_mode = Deal_mode_NONE,
    const char *price = nullptr,
    const char *qty = nullptr,
    const char *deal_qty = nullptr,
    const char *os_qty = nullptr,
    const char *entrust_no = nullptr,
    const char *related_entrust_no = nullptr,
    Entrust_status status = Entrust_status_NONE,
    uint16_t loan_ratio = 0,
    TerminalType input_channel = TerminalType_NONE,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr,
    flatbuffers::Offset<Deal_summary> deal = 0,
    flatbuffers::Offset<Fee> fee = 0,
    flatbuffers::Offset<SpecialCond> spec_cond = 0,
    const char *update_time = nullptr,
    bool T_1 = false,
    const char *sub_status = nullptr) {
  return mm::CreateEntrust(
      _fbb,
      acc,
      market,
      symbol ? _fbb.CreateString(symbol) : 0,
      order_time ? _fbb.CreateString(order_time) : 0,
      ccy,
      direction,
      price_mode,
      deal_mode,
      price ? _fbb.CreateString(price) : 0,
      qty ? _fbb.CreateString(qty) : 0,
      deal_qty ? _fbb.CreateString(deal_qty) : 0,
      os_qty ? _fbb.CreateString(os_qty) : 0,
      entrust_no ? _fbb.CreateString(entrust_no) : 0,
      related_entrust_no ? _fbb.CreateString(related_entrust_no) : 0,
      status,
      loan_ratio,
      input_channel,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0,
      deal,
      fee,
      spec_cond,
      update_time ? _fbb.CreateString(update_time) : 0,
      T_1,
      sub_status ? _fbb.CreateString(sub_status) : 0);
}

struct SpecialCond FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SPEC_TYPE = 4,
    VT_SPEC_DIRECTION = 6,
    VT_TRIGGER_PRICE = 8,
    VT_STOP_LOSS_PRICE = 10,
    VT_PURSUIT_PRICE = 12,
    VT_STEP = 14,
    VT_TARGET_PROFIT_PRICE = 16,
    VT_EXTRAS = 18
  };
  SpecialType Spec_type() const {
    return static_cast<SpecialType>(GetField<uint8_t>(VT_SPEC_TYPE, 0));
  }
  Entrust_mode Spec_direction() const {
    return static_cast<Entrust_mode>(GetField<uint8_t>(VT_SPEC_DIRECTION, 0));
  }
  const flatbuffers::String *trigger_price() const {
    return GetPointer<const flatbuffers::String *>(VT_TRIGGER_PRICE);
  }
  const flatbuffers::String *stop_loss_price() const {
    return GetPointer<const flatbuffers::String *>(VT_STOP_LOSS_PRICE);
  }
  const flatbuffers::String *pursuit_price() const {
    return GetPointer<const flatbuffers::String *>(VT_PURSUIT_PRICE);
  }
  const flatbuffers::String *step() const {
    return GetPointer<const flatbuffers::String *>(VT_STEP);
  }
  const flatbuffers::String *target_profit_price() const {
    return GetPointer<const flatbuffers::String *>(VT_TARGET_PROFIT_PRICE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SPEC_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_SPEC_DIRECTION) &&
           VerifyOffset(verifier, VT_TRIGGER_PRICE) &&
           verifier.Verify(trigger_price()) &&
           VerifyOffset(verifier, VT_STOP_LOSS_PRICE) &&
           verifier.Verify(stop_loss_price()) &&
           VerifyOffset(verifier, VT_PURSUIT_PRICE) &&
           verifier.Verify(pursuit_price()) &&
           VerifyOffset(verifier, VT_STEP) &&
           verifier.Verify(step()) &&
           VerifyOffset(verifier, VT_TARGET_PROFIT_PRICE) &&
           verifier.Verify(target_profit_price()) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           verifier.EndTable();
  }
};

struct SpecialCondBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Spec_type(SpecialType Spec_type) {
    fbb_.AddElement<uint8_t>(SpecialCond::VT_SPEC_TYPE, static_cast<uint8_t>(Spec_type), 0);
  }
  void add_Spec_direction(Entrust_mode Spec_direction) {
    fbb_.AddElement<uint8_t>(SpecialCond::VT_SPEC_DIRECTION, static_cast<uint8_t>(Spec_direction), 0);
  }
  void add_trigger_price(flatbuffers::Offset<flatbuffers::String> trigger_price) {
    fbb_.AddOffset(SpecialCond::VT_TRIGGER_PRICE, trigger_price);
  }
  void add_stop_loss_price(flatbuffers::Offset<flatbuffers::String> stop_loss_price) {
    fbb_.AddOffset(SpecialCond::VT_STOP_LOSS_PRICE, stop_loss_price);
  }
  void add_pursuit_price(flatbuffers::Offset<flatbuffers::String> pursuit_price) {
    fbb_.AddOffset(SpecialCond::VT_PURSUIT_PRICE, pursuit_price);
  }
  void add_step(flatbuffers::Offset<flatbuffers::String> step) {
    fbb_.AddOffset(SpecialCond::VT_STEP, step);
  }
  void add_target_profit_price(flatbuffers::Offset<flatbuffers::String> target_profit_price) {
    fbb_.AddOffset(SpecialCond::VT_TARGET_PROFIT_PRICE, target_profit_price);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(SpecialCond::VT_EXTRAS, extras);
  }
  explicit SpecialCondBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SpecialCondBuilder &operator=(const SpecialCondBuilder &);
  flatbuffers::Offset<SpecialCond> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpecialCond>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpecialCond> CreateSpecialCond(
    flatbuffers::FlatBufferBuilder &_fbb,
    SpecialType Spec_type = SpecialType_NONE,
    Entrust_mode Spec_direction = Entrust_mode_NONE,
    flatbuffers::Offset<flatbuffers::String> trigger_price = 0,
    flatbuffers::Offset<flatbuffers::String> stop_loss_price = 0,
    flatbuffers::Offset<flatbuffers::String> pursuit_price = 0,
    flatbuffers::Offset<flatbuffers::String> step = 0,
    flatbuffers::Offset<flatbuffers::String> target_profit_price = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0) {
  SpecialCondBuilder builder_(_fbb);
  builder_.add_extras(extras);
  builder_.add_target_profit_price(target_profit_price);
  builder_.add_step(step);
  builder_.add_pursuit_price(pursuit_price);
  builder_.add_stop_loss_price(stop_loss_price);
  builder_.add_trigger_price(trigger_price);
  builder_.add_Spec_direction(Spec_direction);
  builder_.add_Spec_type(Spec_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<SpecialCond> CreateSpecialCondDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    SpecialType Spec_type = SpecialType_NONE,
    Entrust_mode Spec_direction = Entrust_mode_NONE,
    const char *trigger_price = nullptr,
    const char *stop_loss_price = nullptr,
    const char *pursuit_price = nullptr,
    const char *step = nullptr,
    const char *target_profit_price = nullptr,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr) {
  return mm::CreateSpecialCond(
      _fbb,
      Spec_type,
      Spec_direction,
      trigger_price ? _fbb.CreateString(trigger_price) : 0,
      stop_loss_price ? _fbb.CreateString(stop_loss_price) : 0,
      pursuit_price ? _fbb.CreateString(pursuit_price) : 0,
      step ? _fbb.CreateString(step) : 0,
      target_profit_price ? _fbb.CreateString(target_profit_price) : 0,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0);
}

struct Login FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACC = 4,
    VT_PWD = 6,
    VT_DEVICE_CODE = 8,
    VT_DEVICE_NAME = 10,
    VT_OTP = 12,
    VT_LANGUAGE = 14,
    VT_IP = 16,
    VT_TERMINAL = 18,
    VT_ENCRYPT_KEY = 20,
    VT_PUSH_SERIALNO = 22,
    VT_EXTRAS = 24
  };
  const Account *acc() const {
    return GetPointer<const Account *>(VT_ACC);
  }
  const flatbuffers::String *pwd() const {
    return GetPointer<const flatbuffers::String *>(VT_PWD);
  }
  const flatbuffers::String *device_code() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICE_CODE);
  }
  const flatbuffers::String *device_name() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICE_NAME);
  }
  const flatbuffers::String *otp() const {
    return GetPointer<const flatbuffers::String *>(VT_OTP);
  }
  Lang language() const {
    return static_cast<Lang>(GetField<uint8_t>(VT_LANGUAGE, 0));
  }
  const flatbuffers::String *ip() const {
    return GetPointer<const flatbuffers::String *>(VT_IP);
  }
  TerminalType terminal() const {
    return static_cast<TerminalType>(GetField<uint8_t>(VT_TERMINAL, 0));
  }
  const flatbuffers::String *encrypt_key() const {
    return GetPointer<const flatbuffers::String *>(VT_ENCRYPT_KEY);
  }
  uint32_t push_serialno() const {
    return GetField<uint32_t>(VT_PUSH_SERIALNO, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACC) &&
           verifier.VerifyTable(acc()) &&
           VerifyOffset(verifier, VT_PWD) &&
           verifier.Verify(pwd()) &&
           VerifyOffset(verifier, VT_DEVICE_CODE) &&
           verifier.Verify(device_code()) &&
           VerifyOffset(verifier, VT_DEVICE_NAME) &&
           verifier.Verify(device_name()) &&
           VerifyOffset(verifier, VT_OTP) &&
           verifier.Verify(otp()) &&
           VerifyField<uint8_t>(verifier, VT_LANGUAGE) &&
           VerifyOffset(verifier, VT_IP) &&
           verifier.Verify(ip()) &&
           VerifyField<uint8_t>(verifier, VT_TERMINAL) &&
           VerifyOffset(verifier, VT_ENCRYPT_KEY) &&
           verifier.Verify(encrypt_key()) &&
           VerifyField<uint32_t>(verifier, VT_PUSH_SERIALNO) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           verifier.EndTable();
  }
};

struct LoginBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acc(flatbuffers::Offset<Account> acc) {
    fbb_.AddOffset(Login::VT_ACC, acc);
  }
  void add_pwd(flatbuffers::Offset<flatbuffers::String> pwd) {
    fbb_.AddOffset(Login::VT_PWD, pwd);
  }
  void add_device_code(flatbuffers::Offset<flatbuffers::String> device_code) {
    fbb_.AddOffset(Login::VT_DEVICE_CODE, device_code);
  }
  void add_device_name(flatbuffers::Offset<flatbuffers::String> device_name) {
    fbb_.AddOffset(Login::VT_DEVICE_NAME, device_name);
  }
  void add_otp(flatbuffers::Offset<flatbuffers::String> otp) {
    fbb_.AddOffset(Login::VT_OTP, otp);
  }
  void add_language(Lang language) {
    fbb_.AddElement<uint8_t>(Login::VT_LANGUAGE, static_cast<uint8_t>(language), 0);
  }
  void add_ip(flatbuffers::Offset<flatbuffers::String> ip) {
    fbb_.AddOffset(Login::VT_IP, ip);
  }
  void add_terminal(TerminalType terminal) {
    fbb_.AddElement<uint8_t>(Login::VT_TERMINAL, static_cast<uint8_t>(terminal), 0);
  }
  void add_encrypt_key(flatbuffers::Offset<flatbuffers::String> encrypt_key) {
    fbb_.AddOffset(Login::VT_ENCRYPT_KEY, encrypt_key);
  }
  void add_push_serialno(uint32_t push_serialno) {
    fbb_.AddElement<uint32_t>(Login::VT_PUSH_SERIALNO, push_serialno, 0);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(Login::VT_EXTRAS, extras);
  }
  explicit LoginBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LoginBuilder &operator=(const LoginBuilder &);
  flatbuffers::Offset<Login> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Login>(end);
    return o;
  }
};

inline flatbuffers::Offset<Login> CreateLogin(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    flatbuffers::Offset<flatbuffers::String> pwd = 0,
    flatbuffers::Offset<flatbuffers::String> device_code = 0,
    flatbuffers::Offset<flatbuffers::String> device_name = 0,
    flatbuffers::Offset<flatbuffers::String> otp = 0,
    Lang language = Lang_ENG,
    flatbuffers::Offset<flatbuffers::String> ip = 0,
    TerminalType terminal = TerminalType_NONE,
    flatbuffers::Offset<flatbuffers::String> encrypt_key = 0,
    uint32_t push_serialno = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0) {
  LoginBuilder builder_(_fbb);
  builder_.add_extras(extras);
  builder_.add_push_serialno(push_serialno);
  builder_.add_encrypt_key(encrypt_key);
  builder_.add_ip(ip);
  builder_.add_otp(otp);
  builder_.add_device_name(device_name);
  builder_.add_device_code(device_code);
  builder_.add_pwd(pwd);
  builder_.add_acc(acc);
  builder_.add_terminal(terminal);
  builder_.add_language(language);
  return builder_.Finish();
}

inline flatbuffers::Offset<Login> CreateLoginDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    const char *pwd = nullptr,
    const char *device_code = nullptr,
    const char *device_name = nullptr,
    const char *otp = nullptr,
    Lang language = Lang_ENG,
    const char *ip = nullptr,
    TerminalType terminal = TerminalType_NONE,
    const char *encrypt_key = nullptr,
    uint32_t push_serialno = 0,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr) {
  return mm::CreateLogin(
      _fbb,
      acc,
      pwd ? _fbb.CreateString(pwd) : 0,
      device_code ? _fbb.CreateString(device_code) : 0,
      device_name ? _fbb.CreateString(device_name) : 0,
      otp ? _fbb.CreateString(otp) : 0,
      language,
      ip ? _fbb.CreateString(ip) : 0,
      terminal,
      encrypt_key ? _fbb.CreateString(encrypt_key) : 0,
      push_serialno,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0);
}

struct Login_rsp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RSP = 4,
    VT_ACC = 6,
    VT_NAME = 8,
    VT_STATUS = 10,
    VT_LAST_LOGIN_TIME = 12,
    VT_ENCRYPT_KEY = 14,
    VT_SESSION = 16,
    VT_EXTRAS = 18
  };
  const Result *rsp() const {
    return GetPointer<const Result *>(VT_RSP);
  }
  const Account *acc() const {
    return GetPointer<const Account *>(VT_ACC);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  Status status() const {
    return static_cast<Status>(GetField<uint8_t>(VT_STATUS, 0));
  }
  const flatbuffers::String *last_login_time() const {
    return GetPointer<const flatbuffers::String *>(VT_LAST_LOGIN_TIME);
  }
  const flatbuffers::String *encrypt_key() const {
    return GetPointer<const flatbuffers::String *>(VT_ENCRYPT_KEY);
  }
  const flatbuffers::String *session() const {
    return GetPointer<const flatbuffers::String *>(VT_SESSION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RSP) &&
           verifier.VerifyTable(rsp()) &&
           VerifyOffset(verifier, VT_ACC) &&
           verifier.VerifyTable(acc()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<uint8_t>(verifier, VT_STATUS) &&
           VerifyOffset(verifier, VT_LAST_LOGIN_TIME) &&
           verifier.Verify(last_login_time()) &&
           VerifyOffset(verifier, VT_ENCRYPT_KEY) &&
           verifier.Verify(encrypt_key()) &&
           VerifyOffset(verifier, VT_SESSION) &&
           verifier.Verify(session()) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           verifier.EndTable();
  }
};

struct Login_rspBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rsp(flatbuffers::Offset<Result> rsp) {
    fbb_.AddOffset(Login_rsp::VT_RSP, rsp);
  }
  void add_acc(flatbuffers::Offset<Account> acc) {
    fbb_.AddOffset(Login_rsp::VT_ACC, acc);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Login_rsp::VT_NAME, name);
  }
  void add_status(Status status) {
    fbb_.AddElement<uint8_t>(Login_rsp::VT_STATUS, static_cast<uint8_t>(status), 0);
  }
  void add_last_login_time(flatbuffers::Offset<flatbuffers::String> last_login_time) {
    fbb_.AddOffset(Login_rsp::VT_LAST_LOGIN_TIME, last_login_time);
  }
  void add_encrypt_key(flatbuffers::Offset<flatbuffers::String> encrypt_key) {
    fbb_.AddOffset(Login_rsp::VT_ENCRYPT_KEY, encrypt_key);
  }
  void add_session(flatbuffers::Offset<flatbuffers::String> session) {
    fbb_.AddOffset(Login_rsp::VT_SESSION, session);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(Login_rsp::VT_EXTRAS, extras);
  }
  explicit Login_rspBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Login_rspBuilder &operator=(const Login_rspBuilder &);
  flatbuffers::Offset<Login_rsp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Login_rsp>(end);
    return o;
  }
};

inline flatbuffers::Offset<Login_rsp> CreateLogin_rsp(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Result> rsp = 0,
    flatbuffers::Offset<Account> acc = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    Status status = Status_NONE,
    flatbuffers::Offset<flatbuffers::String> last_login_time = 0,
    flatbuffers::Offset<flatbuffers::String> encrypt_key = 0,
    flatbuffers::Offset<flatbuffers::String> session = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0) {
  Login_rspBuilder builder_(_fbb);
  builder_.add_extras(extras);
  builder_.add_session(session);
  builder_.add_encrypt_key(encrypt_key);
  builder_.add_last_login_time(last_login_time);
  builder_.add_name(name);
  builder_.add_acc(acc);
  builder_.add_rsp(rsp);
  builder_.add_status(status);
  return builder_.Finish();
}

inline flatbuffers::Offset<Login_rsp> CreateLogin_rspDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Result> rsp = 0,
    flatbuffers::Offset<Account> acc = 0,
    const char *name = nullptr,
    Status status = Status_NONE,
    const char *last_login_time = nullptr,
    const char *encrypt_key = nullptr,
    const char *session = nullptr,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr) {
  return mm::CreateLogin_rsp(
      _fbb,
      rsp,
      acc,
      name ? _fbb.CreateString(name) : 0,
      status,
      last_login_time ? _fbb.CreateString(last_login_time) : 0,
      encrypt_key ? _fbb.CreateString(encrypt_key) : 0,
      session ? _fbb.CreateString(session) : 0,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0);
}

struct ChangePwd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACC = 4,
    VT_PWD = 6,
    VT_NEWPWD = 8,
    VT_OTP = 10,
    VT_EXTRAS = 12
  };
  const Account *acc() const {
    return GetPointer<const Account *>(VT_ACC);
  }
  const flatbuffers::String *pwd() const {
    return GetPointer<const flatbuffers::String *>(VT_PWD);
  }
  const flatbuffers::String *newpwd() const {
    return GetPointer<const flatbuffers::String *>(VT_NEWPWD);
  }
  const flatbuffers::String *otp() const {
    return GetPointer<const flatbuffers::String *>(VT_OTP);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACC) &&
           verifier.VerifyTable(acc()) &&
           VerifyOffset(verifier, VT_PWD) &&
           verifier.Verify(pwd()) &&
           VerifyOffset(verifier, VT_NEWPWD) &&
           verifier.Verify(newpwd()) &&
           VerifyOffset(verifier, VT_OTP) &&
           verifier.Verify(otp()) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           verifier.EndTable();
  }
};

struct ChangePwdBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acc(flatbuffers::Offset<Account> acc) {
    fbb_.AddOffset(ChangePwd::VT_ACC, acc);
  }
  void add_pwd(flatbuffers::Offset<flatbuffers::String> pwd) {
    fbb_.AddOffset(ChangePwd::VT_PWD, pwd);
  }
  void add_newpwd(flatbuffers::Offset<flatbuffers::String> newpwd) {
    fbb_.AddOffset(ChangePwd::VT_NEWPWD, newpwd);
  }
  void add_otp(flatbuffers::Offset<flatbuffers::String> otp) {
    fbb_.AddOffset(ChangePwd::VT_OTP, otp);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(ChangePwd::VT_EXTRAS, extras);
  }
  explicit ChangePwdBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChangePwdBuilder &operator=(const ChangePwdBuilder &);
  flatbuffers::Offset<ChangePwd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChangePwd>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChangePwd> CreateChangePwd(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    flatbuffers::Offset<flatbuffers::String> pwd = 0,
    flatbuffers::Offset<flatbuffers::String> newpwd = 0,
    flatbuffers::Offset<flatbuffers::String> otp = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0) {
  ChangePwdBuilder builder_(_fbb);
  builder_.add_extras(extras);
  builder_.add_otp(otp);
  builder_.add_newpwd(newpwd);
  builder_.add_pwd(pwd);
  builder_.add_acc(acc);
  return builder_.Finish();
}

inline flatbuffers::Offset<ChangePwd> CreateChangePwdDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    const char *pwd = nullptr,
    const char *newpwd = nullptr,
    const char *otp = nullptr,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr) {
  return mm::CreateChangePwd(
      _fbb,
      acc,
      pwd ? _fbb.CreateString(pwd) : 0,
      newpwd ? _fbb.CreateString(newpwd) : 0,
      otp ? _fbb.CreateString(otp) : 0,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0);
}

struct QueryConsign FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACC = 4,
    VT_PAGE = 6,
    VT_MARKET = 8,
    VT_SYMBOL = 10,
    VT_BEGIN_DATE = 12,
    VT_END_DATE = 14,
    VT_EXTRAS = 16
  };
  const Account *acc() const {
    return GetPointer<const Account *>(VT_ACC);
  }
  const Query_page *page() const {
    return GetPointer<const Query_page *>(VT_PAGE);
  }
  Market market() const {
    return static_cast<Market>(GetField<uint8_t>(VT_MARKET, 0));
  }
  const flatbuffers::String *symbol() const {
    return GetPointer<const flatbuffers::String *>(VT_SYMBOL);
  }
  const flatbuffers::String *begin_date() const {
    return GetPointer<const flatbuffers::String *>(VT_BEGIN_DATE);
  }
  const flatbuffers::String *end_date() const {
    return GetPointer<const flatbuffers::String *>(VT_END_DATE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACC) &&
           verifier.VerifyTable(acc()) &&
           VerifyOffset(verifier, VT_PAGE) &&
           verifier.VerifyTable(page()) &&
           VerifyField<uint8_t>(verifier, VT_MARKET) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.Verify(symbol()) &&
           VerifyOffset(verifier, VT_BEGIN_DATE) &&
           verifier.Verify(begin_date()) &&
           VerifyOffset(verifier, VT_END_DATE) &&
           verifier.Verify(end_date()) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           verifier.EndTable();
  }
};

struct QueryConsignBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acc(flatbuffers::Offset<Account> acc) {
    fbb_.AddOffset(QueryConsign::VT_ACC, acc);
  }
  void add_page(flatbuffers::Offset<Query_page> page) {
    fbb_.AddOffset(QueryConsign::VT_PAGE, page);
  }
  void add_market(Market market) {
    fbb_.AddElement<uint8_t>(QueryConsign::VT_MARKET, static_cast<uint8_t>(market), 0);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) {
    fbb_.AddOffset(QueryConsign::VT_SYMBOL, symbol);
  }
  void add_begin_date(flatbuffers::Offset<flatbuffers::String> begin_date) {
    fbb_.AddOffset(QueryConsign::VT_BEGIN_DATE, begin_date);
  }
  void add_end_date(flatbuffers::Offset<flatbuffers::String> end_date) {
    fbb_.AddOffset(QueryConsign::VT_END_DATE, end_date);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(QueryConsign::VT_EXTRAS, extras);
  }
  explicit QueryConsignBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QueryConsignBuilder &operator=(const QueryConsignBuilder &);
  flatbuffers::Offset<QueryConsign> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QueryConsign>(end);
    return o;
  }
};

inline flatbuffers::Offset<QueryConsign> CreateQueryConsign(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    flatbuffers::Offset<Query_page> page = 0,
    Market market = Market_NONE,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    flatbuffers::Offset<flatbuffers::String> begin_date = 0,
    flatbuffers::Offset<flatbuffers::String> end_date = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0) {
  QueryConsignBuilder builder_(_fbb);
  builder_.add_extras(extras);
  builder_.add_end_date(end_date);
  builder_.add_begin_date(begin_date);
  builder_.add_symbol(symbol);
  builder_.add_page(page);
  builder_.add_acc(acc);
  builder_.add_market(market);
  return builder_.Finish();
}

inline flatbuffers::Offset<QueryConsign> CreateQueryConsignDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    flatbuffers::Offset<Query_page> page = 0,
    Market market = Market_NONE,
    const char *symbol = nullptr,
    const char *begin_date = nullptr,
    const char *end_date = nullptr,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr) {
  return mm::CreateQueryConsign(
      _fbb,
      acc,
      page,
      market,
      symbol ? _fbb.CreateString(symbol) : 0,
      begin_date ? _fbb.CreateString(begin_date) : 0,
      end_date ? _fbb.CreateString(end_date) : 0,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0);
}

struct QueryConsign_rsp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RSP = 4,
    VT_PAGE = 6,
    VT_ORDERS = 8,
    VT_EXTRAS = 10,
    VT_ACC = 12
  };
  const Result *rsp() const {
    return GetPointer<const Result *>(VT_RSP);
  }
  const Query_page *page() const {
    return GetPointer<const Query_page *>(VT_PAGE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Entrust>> *orders() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Entrust>> *>(VT_ORDERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  const Account *acc() const {
    return GetPointer<const Account *>(VT_ACC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RSP) &&
           verifier.VerifyTable(rsp()) &&
           VerifyOffset(verifier, VT_PAGE) &&
           verifier.VerifyTable(page()) &&
           VerifyOffset(verifier, VT_ORDERS) &&
           verifier.Verify(orders()) &&
           verifier.VerifyVectorOfTables(orders()) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           VerifyOffset(verifier, VT_ACC) &&
           verifier.VerifyTable(acc()) &&
           verifier.EndTable();
  }
};

struct QueryConsign_rspBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rsp(flatbuffers::Offset<Result> rsp) {
    fbb_.AddOffset(QueryConsign_rsp::VT_RSP, rsp);
  }
  void add_page(flatbuffers::Offset<Query_page> page) {
    fbb_.AddOffset(QueryConsign_rsp::VT_PAGE, page);
  }
  void add_orders(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Entrust>>> orders) {
    fbb_.AddOffset(QueryConsign_rsp::VT_ORDERS, orders);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(QueryConsign_rsp::VT_EXTRAS, extras);
  }
  void add_acc(flatbuffers::Offset<Account> acc) {
    fbb_.AddOffset(QueryConsign_rsp::VT_ACC, acc);
  }
  explicit QueryConsign_rspBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QueryConsign_rspBuilder &operator=(const QueryConsign_rspBuilder &);
  flatbuffers::Offset<QueryConsign_rsp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QueryConsign_rsp>(end);
    return o;
  }
};

inline flatbuffers::Offset<QueryConsign_rsp> CreateQueryConsign_rsp(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Result> rsp = 0,
    flatbuffers::Offset<Query_page> page = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Entrust>>> orders = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0,
    flatbuffers::Offset<Account> acc = 0) {
  QueryConsign_rspBuilder builder_(_fbb);
  builder_.add_acc(acc);
  builder_.add_extras(extras);
  builder_.add_orders(orders);
  builder_.add_page(page);
  builder_.add_rsp(rsp);
  return builder_.Finish();
}

inline flatbuffers::Offset<QueryConsign_rsp> CreateQueryConsign_rspDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Result> rsp = 0,
    flatbuffers::Offset<Query_page> page = 0,
    const std::vector<flatbuffers::Offset<Entrust>> *orders = nullptr,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr,
    flatbuffers::Offset<Account> acc = 0) {
  return mm::CreateQueryConsign_rsp(
      _fbb,
      rsp,
      page,
      orders ? _fbb.CreateVector<flatbuffers::Offset<Entrust>>(*orders) : 0,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0,
      acc);
}

struct Query_hold FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACC = 4,
    VT_PAGE = 6,
    VT_MARKET = 8,
    VT_EXTRAS = 10
  };
  const Account *acc() const {
    return GetPointer<const Account *>(VT_ACC);
  }
  const Query_page *page() const {
    return GetPointer<const Query_page *>(VT_PAGE);
  }
  Market market() const {
    return static_cast<Market>(GetField<uint8_t>(VT_MARKET, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACC) &&
           verifier.VerifyTable(acc()) &&
           VerifyOffset(verifier, VT_PAGE) &&
           verifier.VerifyTable(page()) &&
           VerifyField<uint8_t>(verifier, VT_MARKET) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           verifier.EndTable();
  }
};

struct Query_holdBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acc(flatbuffers::Offset<Account> acc) {
    fbb_.AddOffset(Query_hold::VT_ACC, acc);
  }
  void add_page(flatbuffers::Offset<Query_page> page) {
    fbb_.AddOffset(Query_hold::VT_PAGE, page);
  }
  void add_market(Market market) {
    fbb_.AddElement<uint8_t>(Query_hold::VT_MARKET, static_cast<uint8_t>(market), 0);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(Query_hold::VT_EXTRAS, extras);
  }
  explicit Query_holdBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Query_holdBuilder &operator=(const Query_holdBuilder &);
  flatbuffers::Offset<Query_hold> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Query_hold>(end);
    return o;
  }
};

inline flatbuffers::Offset<Query_hold> CreateQuery_hold(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    flatbuffers::Offset<Query_page> page = 0,
    Market market = Market_NONE,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0) {
  Query_holdBuilder builder_(_fbb);
  builder_.add_extras(extras);
  builder_.add_page(page);
  builder_.add_acc(acc);
  builder_.add_market(market);
  return builder_.Finish();
}

inline flatbuffers::Offset<Query_hold> CreateQuery_holdDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    flatbuffers::Offset<Query_page> page = 0,
    Market market = Market_NONE,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr) {
  return mm::CreateQuery_hold(
      _fbb,
      acc,
      page,
      market,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0);
}

struct Query_hold_rsp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RES = 4,
    VT_PAGE = 6,
    VT_HOLDS = 8,
    VT_EXTRAS = 10,
    VT_ACC = 12
  };
  const Result *res() const {
    return GetPointer<const Result *>(VT_RES);
  }
  const Query_page *page() const {
    return GetPointer<const Query_page *>(VT_PAGE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Hold>> *holds() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Hold>> *>(VT_HOLDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  const Account *acc() const {
    return GetPointer<const Account *>(VT_ACC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RES) &&
           verifier.VerifyTable(res()) &&
           VerifyOffset(verifier, VT_PAGE) &&
           verifier.VerifyTable(page()) &&
           VerifyOffset(verifier, VT_HOLDS) &&
           verifier.Verify(holds()) &&
           verifier.VerifyVectorOfTables(holds()) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           VerifyOffset(verifier, VT_ACC) &&
           verifier.VerifyTable(acc()) &&
           verifier.EndTable();
  }
};

struct Query_hold_rspBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_res(flatbuffers::Offset<Result> res) {
    fbb_.AddOffset(Query_hold_rsp::VT_RES, res);
  }
  void add_page(flatbuffers::Offset<Query_page> page) {
    fbb_.AddOffset(Query_hold_rsp::VT_PAGE, page);
  }
  void add_holds(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Hold>>> holds) {
    fbb_.AddOffset(Query_hold_rsp::VT_HOLDS, holds);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(Query_hold_rsp::VT_EXTRAS, extras);
  }
  void add_acc(flatbuffers::Offset<Account> acc) {
    fbb_.AddOffset(Query_hold_rsp::VT_ACC, acc);
  }
  explicit Query_hold_rspBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Query_hold_rspBuilder &operator=(const Query_hold_rspBuilder &);
  flatbuffers::Offset<Query_hold_rsp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Query_hold_rsp>(end);
    return o;
  }
};

inline flatbuffers::Offset<Query_hold_rsp> CreateQuery_hold_rsp(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Result> res = 0,
    flatbuffers::Offset<Query_page> page = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Hold>>> holds = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0,
    flatbuffers::Offset<Account> acc = 0) {
  Query_hold_rspBuilder builder_(_fbb);
  builder_.add_acc(acc);
  builder_.add_extras(extras);
  builder_.add_holds(holds);
  builder_.add_page(page);
  builder_.add_res(res);
  return builder_.Finish();
}

inline flatbuffers::Offset<Query_hold_rsp> CreateQuery_hold_rspDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Result> res = 0,
    flatbuffers::Offset<Query_page> page = 0,
    const std::vector<flatbuffers::Offset<Hold>> *holds = nullptr,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr,
    flatbuffers::Offset<Account> acc = 0) {
  return mm::CreateQuery_hold_rsp(
      _fbb,
      res,
      page,
      holds ? _fbb.CreateVector<flatbuffers::Offset<Hold>>(*holds) : 0,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0,
      acc);
}

struct Query_fund FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACC = 4,
    VT_CCY = 6,
    VT_EXTRAS = 8
  };
  const Account *acc() const {
    return GetPointer<const Account *>(VT_ACC);
  }
  Currency ccy() const {
    return static_cast<Currency>(GetField<uint8_t>(VT_CCY, 2));
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACC) &&
           verifier.VerifyTable(acc()) &&
           VerifyField<uint8_t>(verifier, VT_CCY) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           verifier.EndTable();
  }
};

struct Query_fundBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acc(flatbuffers::Offset<Account> acc) {
    fbb_.AddOffset(Query_fund::VT_ACC, acc);
  }
  void add_ccy(Currency ccy) {
    fbb_.AddElement<uint8_t>(Query_fund::VT_CCY, static_cast<uint8_t>(ccy), 2);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(Query_fund::VT_EXTRAS, extras);
  }
  explicit Query_fundBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Query_fundBuilder &operator=(const Query_fundBuilder &);
  flatbuffers::Offset<Query_fund> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Query_fund>(end);
    return o;
  }
};

inline flatbuffers::Offset<Query_fund> CreateQuery_fund(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    Currency ccy = Currency_HKD,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0) {
  Query_fundBuilder builder_(_fbb);
  builder_.add_extras(extras);
  builder_.add_acc(acc);
  builder_.add_ccy(ccy);
  return builder_.Finish();
}

inline flatbuffers::Offset<Query_fund> CreateQuery_fundDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    Currency ccy = Currency_HKD,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr) {
  return mm::CreateQuery_fund(
      _fbb,
      acc,
      ccy,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0);
}

struct Query_fund_rsp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RES = 4,
    VT_ITEMS = 6,
    VT_EXTRAS = 8,
    VT_ACC = 10
  };
  const Result *res() const {
    return GetPointer<const Result *>(VT_RES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Fund>> *items() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Fund>> *>(VT_ITEMS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  const Account *acc() const {
    return GetPointer<const Account *>(VT_ACC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RES) &&
           verifier.VerifyTable(res()) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.Verify(items()) &&
           verifier.VerifyVectorOfTables(items()) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           VerifyOffset(verifier, VT_ACC) &&
           verifier.VerifyTable(acc()) &&
           verifier.EndTable();
  }
};

struct Query_fund_rspBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_res(flatbuffers::Offset<Result> res) {
    fbb_.AddOffset(Query_fund_rsp::VT_RES, res);
  }
  void add_items(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fund>>> items) {
    fbb_.AddOffset(Query_fund_rsp::VT_ITEMS, items);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(Query_fund_rsp::VT_EXTRAS, extras);
  }
  void add_acc(flatbuffers::Offset<Account> acc) {
    fbb_.AddOffset(Query_fund_rsp::VT_ACC, acc);
  }
  explicit Query_fund_rspBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Query_fund_rspBuilder &operator=(const Query_fund_rspBuilder &);
  flatbuffers::Offset<Query_fund_rsp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Query_fund_rsp>(end);
    return o;
  }
};

inline flatbuffers::Offset<Query_fund_rsp> CreateQuery_fund_rsp(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Result> res = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fund>>> items = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0,
    flatbuffers::Offset<Account> acc = 0) {
  Query_fund_rspBuilder builder_(_fbb);
  builder_.add_acc(acc);
  builder_.add_extras(extras);
  builder_.add_items(items);
  builder_.add_res(res);
  return builder_.Finish();
}

inline flatbuffers::Offset<Query_fund_rsp> CreateQuery_fund_rspDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Result> res = 0,
    const std::vector<flatbuffers::Offset<Fund>> *items = nullptr,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr,
    flatbuffers::Offset<Account> acc = 0) {
  return mm::CreateQuery_fund_rsp(
      _fbb,
      res,
      items ? _fbb.CreateVector<flatbuffers::Offset<Fund>>(*items) : 0,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0,
      acc);
}

struct QueryBargain FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACC = 4,
    VT_PAGE = 6,
    VT_MARKET = 8,
    VT_SYMBOL = 10,
    VT_ENTRUST_NO = 12,
    VT_BEGIN_DATE = 14,
    VT_END_DATE = 16,
    VT_EXTRAS = 18
  };
  const Account *acc() const {
    return GetPointer<const Account *>(VT_ACC);
  }
  const Query_page *page() const {
    return GetPointer<const Query_page *>(VT_PAGE);
  }
  Market market() const {
    return static_cast<Market>(GetField<uint8_t>(VT_MARKET, 0));
  }
  const flatbuffers::String *symbol() const {
    return GetPointer<const flatbuffers::String *>(VT_SYMBOL);
  }
  const flatbuffers::String *entrust_no() const {
    return GetPointer<const flatbuffers::String *>(VT_ENTRUST_NO);
  }
  const flatbuffers::String *begin_date() const {
    return GetPointer<const flatbuffers::String *>(VT_BEGIN_DATE);
  }
  const flatbuffers::String *end_date() const {
    return GetPointer<const flatbuffers::String *>(VT_END_DATE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACC) &&
           verifier.VerifyTable(acc()) &&
           VerifyOffset(verifier, VT_PAGE) &&
           verifier.VerifyTable(page()) &&
           VerifyField<uint8_t>(verifier, VT_MARKET) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.Verify(symbol()) &&
           VerifyOffset(verifier, VT_ENTRUST_NO) &&
           verifier.Verify(entrust_no()) &&
           VerifyOffset(verifier, VT_BEGIN_DATE) &&
           verifier.Verify(begin_date()) &&
           VerifyOffset(verifier, VT_END_DATE) &&
           verifier.Verify(end_date()) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           verifier.EndTable();
  }
};

struct QueryBargainBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acc(flatbuffers::Offset<Account> acc) {
    fbb_.AddOffset(QueryBargain::VT_ACC, acc);
  }
  void add_page(flatbuffers::Offset<Query_page> page) {
    fbb_.AddOffset(QueryBargain::VT_PAGE, page);
  }
  void add_market(Market market) {
    fbb_.AddElement<uint8_t>(QueryBargain::VT_MARKET, static_cast<uint8_t>(market), 0);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) {
    fbb_.AddOffset(QueryBargain::VT_SYMBOL, symbol);
  }
  void add_entrust_no(flatbuffers::Offset<flatbuffers::String> entrust_no) {
    fbb_.AddOffset(QueryBargain::VT_ENTRUST_NO, entrust_no);
  }
  void add_begin_date(flatbuffers::Offset<flatbuffers::String> begin_date) {
    fbb_.AddOffset(QueryBargain::VT_BEGIN_DATE, begin_date);
  }
  void add_end_date(flatbuffers::Offset<flatbuffers::String> end_date) {
    fbb_.AddOffset(QueryBargain::VT_END_DATE, end_date);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(QueryBargain::VT_EXTRAS, extras);
  }
  explicit QueryBargainBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QueryBargainBuilder &operator=(const QueryBargainBuilder &);
  flatbuffers::Offset<QueryBargain> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QueryBargain>(end);
    return o;
  }
};

inline flatbuffers::Offset<QueryBargain> CreateQueryBargain(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    flatbuffers::Offset<Query_page> page = 0,
    Market market = Market_NONE,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    flatbuffers::Offset<flatbuffers::String> entrust_no = 0,
    flatbuffers::Offset<flatbuffers::String> begin_date = 0,
    flatbuffers::Offset<flatbuffers::String> end_date = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0) {
  QueryBargainBuilder builder_(_fbb);
  builder_.add_extras(extras);
  builder_.add_end_date(end_date);
  builder_.add_begin_date(begin_date);
  builder_.add_entrust_no(entrust_no);
  builder_.add_symbol(symbol);
  builder_.add_page(page);
  builder_.add_acc(acc);
  builder_.add_market(market);
  return builder_.Finish();
}

inline flatbuffers::Offset<QueryBargain> CreateQueryBargainDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    flatbuffers::Offset<Query_page> page = 0,
    Market market = Market_NONE,
    const char *symbol = nullptr,
    const char *entrust_no = nullptr,
    const char *begin_date = nullptr,
    const char *end_date = nullptr,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr) {
  return mm::CreateQueryBargain(
      _fbb,
      acc,
      page,
      market,
      symbol ? _fbb.CreateString(symbol) : 0,
      entrust_no ? _fbb.CreateString(entrust_no) : 0,
      begin_date ? _fbb.CreateString(begin_date) : 0,
      end_date ? _fbb.CreateString(end_date) : 0,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0);
}

struct QueryBargain_rsp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RES = 4,
    VT_PAGE = 6,
    VT_DEALS = 8,
    VT_EXTRAS = 10,
    VT_ACC = 12
  };
  const Result *res() const {
    return GetPointer<const Result *>(VT_RES);
  }
  const Query_page *page() const {
    return GetPointer<const Query_page *>(VT_PAGE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Deal_detail>> *deals() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Deal_detail>> *>(VT_DEALS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  const Account *acc() const {
    return GetPointer<const Account *>(VT_ACC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RES) &&
           verifier.VerifyTable(res()) &&
           VerifyOffset(verifier, VT_PAGE) &&
           verifier.VerifyTable(page()) &&
           VerifyOffset(verifier, VT_DEALS) &&
           verifier.Verify(deals()) &&
           verifier.VerifyVectorOfTables(deals()) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           VerifyOffset(verifier, VT_ACC) &&
           verifier.VerifyTable(acc()) &&
           verifier.EndTable();
  }
};

struct QueryBargain_rspBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_res(flatbuffers::Offset<Result> res) {
    fbb_.AddOffset(QueryBargain_rsp::VT_RES, res);
  }
  void add_page(flatbuffers::Offset<Query_page> page) {
    fbb_.AddOffset(QueryBargain_rsp::VT_PAGE, page);
  }
  void add_deals(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Deal_detail>>> deals) {
    fbb_.AddOffset(QueryBargain_rsp::VT_DEALS, deals);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(QueryBargain_rsp::VT_EXTRAS, extras);
  }
  void add_acc(flatbuffers::Offset<Account> acc) {
    fbb_.AddOffset(QueryBargain_rsp::VT_ACC, acc);
  }
  explicit QueryBargain_rspBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QueryBargain_rspBuilder &operator=(const QueryBargain_rspBuilder &);
  flatbuffers::Offset<QueryBargain_rsp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QueryBargain_rsp>(end);
    return o;
  }
};

inline flatbuffers::Offset<QueryBargain_rsp> CreateQueryBargain_rsp(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Result> res = 0,
    flatbuffers::Offset<Query_page> page = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Deal_detail>>> deals = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0,
    flatbuffers::Offset<Account> acc = 0) {
  QueryBargain_rspBuilder builder_(_fbb);
  builder_.add_acc(acc);
  builder_.add_extras(extras);
  builder_.add_deals(deals);
  builder_.add_page(page);
  builder_.add_res(res);
  return builder_.Finish();
}

inline flatbuffers::Offset<QueryBargain_rsp> CreateQueryBargain_rspDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Result> res = 0,
    flatbuffers::Offset<Query_page> page = 0,
    const std::vector<flatbuffers::Offset<Deal_detail>> *deals = nullptr,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr,
    flatbuffers::Offset<Account> acc = 0) {
  return mm::CreateQueryBargain_rsp(
      _fbb,
      res,
      page,
      deals ? _fbb.CreateVector<flatbuffers::Offset<Deal_detail>>(*deals) : 0,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0,
      acc);
}

struct QueryCapital FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACC = 4,
    VT_CCY = 6,
    VT_PAGE = 8,
    VT_DATE_FROM = 10,
    VT_DATE_TO = 12,
    VT_EXTRAS = 14
  };
  const Account *acc() const {
    return GetPointer<const Account *>(VT_ACC);
  }
  Currency ccy() const {
    return static_cast<Currency>(GetField<uint8_t>(VT_CCY, 0));
  }
  const Query_page *page() const {
    return GetPointer<const Query_page *>(VT_PAGE);
  }
  const flatbuffers::String *date_from() const {
    return GetPointer<const flatbuffers::String *>(VT_DATE_FROM);
  }
  const flatbuffers::String *date_to() const {
    return GetPointer<const flatbuffers::String *>(VT_DATE_TO);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACC) &&
           verifier.VerifyTable(acc()) &&
           VerifyField<uint8_t>(verifier, VT_CCY) &&
           VerifyOffset(verifier, VT_PAGE) &&
           verifier.VerifyTable(page()) &&
           VerifyOffset(verifier, VT_DATE_FROM) &&
           verifier.Verify(date_from()) &&
           VerifyOffset(verifier, VT_DATE_TO) &&
           verifier.Verify(date_to()) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           verifier.EndTable();
  }
};

struct QueryCapitalBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acc(flatbuffers::Offset<Account> acc) {
    fbb_.AddOffset(QueryCapital::VT_ACC, acc);
  }
  void add_ccy(Currency ccy) {
    fbb_.AddElement<uint8_t>(QueryCapital::VT_CCY, static_cast<uint8_t>(ccy), 0);
  }
  void add_page(flatbuffers::Offset<Query_page> page) {
    fbb_.AddOffset(QueryCapital::VT_PAGE, page);
  }
  void add_date_from(flatbuffers::Offset<flatbuffers::String> date_from) {
    fbb_.AddOffset(QueryCapital::VT_DATE_FROM, date_from);
  }
  void add_date_to(flatbuffers::Offset<flatbuffers::String> date_to) {
    fbb_.AddOffset(QueryCapital::VT_DATE_TO, date_to);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(QueryCapital::VT_EXTRAS, extras);
  }
  explicit QueryCapitalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QueryCapitalBuilder &operator=(const QueryCapitalBuilder &);
  flatbuffers::Offset<QueryCapital> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QueryCapital>(end);
    return o;
  }
};

inline flatbuffers::Offset<QueryCapital> CreateQueryCapital(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    Currency ccy = Currency_NONE,
    flatbuffers::Offset<Query_page> page = 0,
    flatbuffers::Offset<flatbuffers::String> date_from = 0,
    flatbuffers::Offset<flatbuffers::String> date_to = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0) {
  QueryCapitalBuilder builder_(_fbb);
  builder_.add_extras(extras);
  builder_.add_date_to(date_to);
  builder_.add_date_from(date_from);
  builder_.add_page(page);
  builder_.add_acc(acc);
  builder_.add_ccy(ccy);
  return builder_.Finish();
}

inline flatbuffers::Offset<QueryCapital> CreateQueryCapitalDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    Currency ccy = Currency_NONE,
    flatbuffers::Offset<Query_page> page = 0,
    const char *date_from = nullptr,
    const char *date_to = nullptr,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr) {
  return mm::CreateQueryCapital(
      _fbb,
      acc,
      ccy,
      page,
      date_from ? _fbb.CreateString(date_from) : 0,
      date_to ? _fbb.CreateString(date_to) : 0,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0);
}

struct Query_capital_rsp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RES = 4,
    VT_PAGE = 6,
    VT_ITEMS = 8,
    VT_EXTRAS = 10
  };
  const Result *res() const {
    return GetPointer<const Result *>(VT_RES);
  }
  const Query_page *page() const {
    return GetPointer<const Query_page *>(VT_PAGE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Capital_detail>> *items() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Capital_detail>> *>(VT_ITEMS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RES) &&
           verifier.VerifyTable(res()) &&
           VerifyOffset(verifier, VT_PAGE) &&
           verifier.VerifyTable(page()) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.Verify(items()) &&
           verifier.VerifyVectorOfTables(items()) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           verifier.EndTable();
  }
};

struct Query_capital_rspBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_res(flatbuffers::Offset<Result> res) {
    fbb_.AddOffset(Query_capital_rsp::VT_RES, res);
  }
  void add_page(flatbuffers::Offset<Query_page> page) {
    fbb_.AddOffset(Query_capital_rsp::VT_PAGE, page);
  }
  void add_items(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Capital_detail>>> items) {
    fbb_.AddOffset(Query_capital_rsp::VT_ITEMS, items);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(Query_capital_rsp::VT_EXTRAS, extras);
  }
  explicit Query_capital_rspBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Query_capital_rspBuilder &operator=(const Query_capital_rspBuilder &);
  flatbuffers::Offset<Query_capital_rsp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Query_capital_rsp>(end);
    return o;
  }
};

inline flatbuffers::Offset<Query_capital_rsp> CreateQuery_capital_rsp(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Result> res = 0,
    flatbuffers::Offset<Query_page> page = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Capital_detail>>> items = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0) {
  Query_capital_rspBuilder builder_(_fbb);
  builder_.add_extras(extras);
  builder_.add_items(items);
  builder_.add_page(page);
  builder_.add_res(res);
  return builder_.Finish();
}

inline flatbuffers::Offset<Query_capital_rsp> CreateQuery_capital_rspDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Result> res = 0,
    flatbuffers::Offset<Query_page> page = 0,
    const std::vector<flatbuffers::Offset<Capital_detail>> *items = nullptr,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr) {
  return mm::CreateQuery_capital_rsp(
      _fbb,
      res,
      page,
      items ? _fbb.CreateVector<flatbuffers::Offset<Capital_detail>>(*items) : 0,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0);
}

struct FundTransfer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACC = 4,
    VT_CCY = 6,
    VT_BANKID = 8,
    VT_SUM = 10,
    VT_MEDIA_TYPE = 12,
    VT_TIME = 14,
    VT_REMARK = 16,
    VT_EXTRAS = 18
  };
  const Account *acc() const {
    return GetPointer<const Account *>(VT_ACC);
  }
  Currency ccy() const {
    return static_cast<Currency>(GetField<uint8_t>(VT_CCY, 0));
  }
  const Bank *bankid() const {
    return GetPointer<const Bank *>(VT_BANKID);
  }
  const flatbuffers::String *sum() const {
    return GetPointer<const flatbuffers::String *>(VT_SUM);
  }
  CashMedia media_type() const {
    return static_cast<CashMedia>(GetField<uint8_t>(VT_MEDIA_TYPE, 0));
  }
  const flatbuffers::String *time() const {
    return GetPointer<const flatbuffers::String *>(VT_TIME);
  }
  const flatbuffers::String *remark() const {
    return GetPointer<const flatbuffers::String *>(VT_REMARK);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACC) &&
           verifier.VerifyTable(acc()) &&
           VerifyField<uint8_t>(verifier, VT_CCY) &&
           VerifyOffset(verifier, VT_BANKID) &&
           verifier.VerifyTable(bankid()) &&
           VerifyOffset(verifier, VT_SUM) &&
           verifier.Verify(sum()) &&
           VerifyField<uint8_t>(verifier, VT_MEDIA_TYPE) &&
           VerifyOffset(verifier, VT_TIME) &&
           verifier.Verify(time()) &&
           VerifyOffset(verifier, VT_REMARK) &&
           verifier.Verify(remark()) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           verifier.EndTable();
  }
};

struct FundTransferBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acc(flatbuffers::Offset<Account> acc) {
    fbb_.AddOffset(FundTransfer::VT_ACC, acc);
  }
  void add_ccy(Currency ccy) {
    fbb_.AddElement<uint8_t>(FundTransfer::VT_CCY, static_cast<uint8_t>(ccy), 0);
  }
  void add_bankid(flatbuffers::Offset<Bank> bankid) {
    fbb_.AddOffset(FundTransfer::VT_BANKID, bankid);
  }
  void add_sum(flatbuffers::Offset<flatbuffers::String> sum) {
    fbb_.AddOffset(FundTransfer::VT_SUM, sum);
  }
  void add_media_type(CashMedia media_type) {
    fbb_.AddElement<uint8_t>(FundTransfer::VT_MEDIA_TYPE, static_cast<uint8_t>(media_type), 0);
  }
  void add_time(flatbuffers::Offset<flatbuffers::String> time) {
    fbb_.AddOffset(FundTransfer::VT_TIME, time);
  }
  void add_remark(flatbuffers::Offset<flatbuffers::String> remark) {
    fbb_.AddOffset(FundTransfer::VT_REMARK, remark);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(FundTransfer::VT_EXTRAS, extras);
  }
  explicit FundTransferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FundTransferBuilder &operator=(const FundTransferBuilder &);
  flatbuffers::Offset<FundTransfer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FundTransfer>(end);
    return o;
  }
};

inline flatbuffers::Offset<FundTransfer> CreateFundTransfer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    Currency ccy = Currency_NONE,
    flatbuffers::Offset<Bank> bankid = 0,
    flatbuffers::Offset<flatbuffers::String> sum = 0,
    CashMedia media_type = CashMedia_NONE,
    flatbuffers::Offset<flatbuffers::String> time = 0,
    flatbuffers::Offset<flatbuffers::String> remark = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0) {
  FundTransferBuilder builder_(_fbb);
  builder_.add_extras(extras);
  builder_.add_remark(remark);
  builder_.add_time(time);
  builder_.add_sum(sum);
  builder_.add_bankid(bankid);
  builder_.add_acc(acc);
  builder_.add_media_type(media_type);
  builder_.add_ccy(ccy);
  return builder_.Finish();
}

inline flatbuffers::Offset<FundTransfer> CreateFundTransferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    Currency ccy = Currency_NONE,
    flatbuffers::Offset<Bank> bankid = 0,
    const char *sum = nullptr,
    CashMedia media_type = CashMedia_NONE,
    const char *time = nullptr,
    const char *remark = nullptr,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr) {
  return mm::CreateFundTransfer(
      _fbb,
      acc,
      ccy,
      bankid,
      sum ? _fbb.CreateString(sum) : 0,
      media_type,
      time ? _fbb.CreateString(time) : 0,
      remark ? _fbb.CreateString(remark) : 0,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0);
}

struct Query_ftflow FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACC = 4,
    VT_PAGE = 6,
    VT_BANKID = 8,
    VT_DATE_FROM = 10,
    VT_DATE_TO = 12,
    VT_EXTRAS = 14
  };
  const Account *acc() const {
    return GetPointer<const Account *>(VT_ACC);
  }
  const Query_page *page() const {
    return GetPointer<const Query_page *>(VT_PAGE);
  }
  const Bank *bankid() const {
    return GetPointer<const Bank *>(VT_BANKID);
  }
  const flatbuffers::String *date_from() const {
    return GetPointer<const flatbuffers::String *>(VT_DATE_FROM);
  }
  const flatbuffers::String *date_to() const {
    return GetPointer<const flatbuffers::String *>(VT_DATE_TO);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACC) &&
           verifier.VerifyTable(acc()) &&
           VerifyOffset(verifier, VT_PAGE) &&
           verifier.VerifyTable(page()) &&
           VerifyOffset(verifier, VT_BANKID) &&
           verifier.VerifyTable(bankid()) &&
           VerifyOffset(verifier, VT_DATE_FROM) &&
           verifier.Verify(date_from()) &&
           VerifyOffset(verifier, VT_DATE_TO) &&
           verifier.Verify(date_to()) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           verifier.EndTable();
  }
};

struct Query_ftflowBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acc(flatbuffers::Offset<Account> acc) {
    fbb_.AddOffset(Query_ftflow::VT_ACC, acc);
  }
  void add_page(flatbuffers::Offset<Query_page> page) {
    fbb_.AddOffset(Query_ftflow::VT_PAGE, page);
  }
  void add_bankid(flatbuffers::Offset<Bank> bankid) {
    fbb_.AddOffset(Query_ftflow::VT_BANKID, bankid);
  }
  void add_date_from(flatbuffers::Offset<flatbuffers::String> date_from) {
    fbb_.AddOffset(Query_ftflow::VT_DATE_FROM, date_from);
  }
  void add_date_to(flatbuffers::Offset<flatbuffers::String> date_to) {
    fbb_.AddOffset(Query_ftflow::VT_DATE_TO, date_to);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(Query_ftflow::VT_EXTRAS, extras);
  }
  explicit Query_ftflowBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Query_ftflowBuilder &operator=(const Query_ftflowBuilder &);
  flatbuffers::Offset<Query_ftflow> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Query_ftflow>(end);
    return o;
  }
};

inline flatbuffers::Offset<Query_ftflow> CreateQuery_ftflow(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    flatbuffers::Offset<Query_page> page = 0,
    flatbuffers::Offset<Bank> bankid = 0,
    flatbuffers::Offset<flatbuffers::String> date_from = 0,
    flatbuffers::Offset<flatbuffers::String> date_to = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0) {
  Query_ftflowBuilder builder_(_fbb);
  builder_.add_extras(extras);
  builder_.add_date_to(date_to);
  builder_.add_date_from(date_from);
  builder_.add_bankid(bankid);
  builder_.add_page(page);
  builder_.add_acc(acc);
  return builder_.Finish();
}

inline flatbuffers::Offset<Query_ftflow> CreateQuery_ftflowDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    flatbuffers::Offset<Query_page> page = 0,
    flatbuffers::Offset<Bank> bankid = 0,
    const char *date_from = nullptr,
    const char *date_to = nullptr,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr) {
  return mm::CreateQuery_ftflow(
      _fbb,
      acc,
      page,
      bankid,
      date_from ? _fbb.CreateString(date_from) : 0,
      date_to ? _fbb.CreateString(date_to) : 0,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0);
}

struct Query_ftflow_rsp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RES = 4,
    VT_PAGE = 6,
    VT_ITEMS = 8,
    VT_EXTRAS = 10
  };
  const Result *res() const {
    return GetPointer<const Result *>(VT_RES);
  }
  const Query_page *page() const {
    return GetPointer<const Query_page *>(VT_PAGE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FundTransfer>> *items() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FundTransfer>> *>(VT_ITEMS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RES) &&
           verifier.VerifyTable(res()) &&
           VerifyOffset(verifier, VT_PAGE) &&
           verifier.VerifyTable(page()) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.Verify(items()) &&
           verifier.VerifyVectorOfTables(items()) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           verifier.EndTable();
  }
};

struct Query_ftflow_rspBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_res(flatbuffers::Offset<Result> res) {
    fbb_.AddOffset(Query_ftflow_rsp::VT_RES, res);
  }
  void add_page(flatbuffers::Offset<Query_page> page) {
    fbb_.AddOffset(Query_ftflow_rsp::VT_PAGE, page);
  }
  void add_items(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FundTransfer>>> items) {
    fbb_.AddOffset(Query_ftflow_rsp::VT_ITEMS, items);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(Query_ftflow_rsp::VT_EXTRAS, extras);
  }
  explicit Query_ftflow_rspBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Query_ftflow_rspBuilder &operator=(const Query_ftflow_rspBuilder &);
  flatbuffers::Offset<Query_ftflow_rsp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Query_ftflow_rsp>(end);
    return o;
  }
};

inline flatbuffers::Offset<Query_ftflow_rsp> CreateQuery_ftflow_rsp(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Result> res = 0,
    flatbuffers::Offset<Query_page> page = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FundTransfer>>> items = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0) {
  Query_ftflow_rspBuilder builder_(_fbb);
  builder_.add_extras(extras);
  builder_.add_items(items);
  builder_.add_page(page);
  builder_.add_res(res);
  return builder_.Finish();
}

inline flatbuffers::Offset<Query_ftflow_rsp> CreateQuery_ftflow_rspDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Result> res = 0,
    flatbuffers::Offset<Query_page> page = 0,
    const std::vector<flatbuffers::Offset<FundTransfer>> *items = nullptr,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr) {
  return mm::CreateQuery_ftflow_rsp(
      _fbb,
      res,
      page,
      items ? _fbb.CreateVector<flatbuffers::Offset<FundTransfer>>(*items) : 0,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0);
}

struct QueryPosition FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACC = 4,
    VT_PAGE = 6,
    VT_MARKET = 8,
    VT_SYMBOL = 10,
    VT_DATE_FROM = 12,
    VT_DATE_TO = 14,
    VT_EXTRAS = 16
  };
  const Account *acc() const {
    return GetPointer<const Account *>(VT_ACC);
  }
  const Query_page *page() const {
    return GetPointer<const Query_page *>(VT_PAGE);
  }
  Market market() const {
    return static_cast<Market>(GetField<uint8_t>(VT_MARKET, 0));
  }
  const flatbuffers::String *symbol() const {
    return GetPointer<const flatbuffers::String *>(VT_SYMBOL);
  }
  const flatbuffers::String *date_from() const {
    return GetPointer<const flatbuffers::String *>(VT_DATE_FROM);
  }
  const flatbuffers::String *date_to() const {
    return GetPointer<const flatbuffers::String *>(VT_DATE_TO);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACC) &&
           verifier.VerifyTable(acc()) &&
           VerifyOffset(verifier, VT_PAGE) &&
           verifier.VerifyTable(page()) &&
           VerifyField<uint8_t>(verifier, VT_MARKET) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.Verify(symbol()) &&
           VerifyOffset(verifier, VT_DATE_FROM) &&
           verifier.Verify(date_from()) &&
           VerifyOffset(verifier, VT_DATE_TO) &&
           verifier.Verify(date_to()) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           verifier.EndTable();
  }
};

struct QueryPositionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acc(flatbuffers::Offset<Account> acc) {
    fbb_.AddOffset(QueryPosition::VT_ACC, acc);
  }
  void add_page(flatbuffers::Offset<Query_page> page) {
    fbb_.AddOffset(QueryPosition::VT_PAGE, page);
  }
  void add_market(Market market) {
    fbb_.AddElement<uint8_t>(QueryPosition::VT_MARKET, static_cast<uint8_t>(market), 0);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) {
    fbb_.AddOffset(QueryPosition::VT_SYMBOL, symbol);
  }
  void add_date_from(flatbuffers::Offset<flatbuffers::String> date_from) {
    fbb_.AddOffset(QueryPosition::VT_DATE_FROM, date_from);
  }
  void add_date_to(flatbuffers::Offset<flatbuffers::String> date_to) {
    fbb_.AddOffset(QueryPosition::VT_DATE_TO, date_to);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(QueryPosition::VT_EXTRAS, extras);
  }
  explicit QueryPositionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QueryPositionBuilder &operator=(const QueryPositionBuilder &);
  flatbuffers::Offset<QueryPosition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QueryPosition>(end);
    return o;
  }
};

inline flatbuffers::Offset<QueryPosition> CreateQueryPosition(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    flatbuffers::Offset<Query_page> page = 0,
    Market market = Market_NONE,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    flatbuffers::Offset<flatbuffers::String> date_from = 0,
    flatbuffers::Offset<flatbuffers::String> date_to = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0) {
  QueryPositionBuilder builder_(_fbb);
  builder_.add_extras(extras);
  builder_.add_date_to(date_to);
  builder_.add_date_from(date_from);
  builder_.add_symbol(symbol);
  builder_.add_page(page);
  builder_.add_acc(acc);
  builder_.add_market(market);
  return builder_.Finish();
}

inline flatbuffers::Offset<QueryPosition> CreateQueryPositionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    flatbuffers::Offset<Query_page> page = 0,
    Market market = Market_NONE,
    const char *symbol = nullptr,
    const char *date_from = nullptr,
    const char *date_to = nullptr,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr) {
  return mm::CreateQueryPosition(
      _fbb,
      acc,
      page,
      market,
      symbol ? _fbb.CreateString(symbol) : 0,
      date_from ? _fbb.CreateString(date_from) : 0,
      date_to ? _fbb.CreateString(date_to) : 0,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0);
}

struct Query_position_rsp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RES = 4,
    VT_PAGE = 6,
    VT_ITEMS = 8,
    VT_EXTRAS = 10
  };
  const Result *res() const {
    return GetPointer<const Result *>(VT_RES);
  }
  const Query_page *page() const {
    return GetPointer<const Query_page *>(VT_PAGE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<PositionNotify>> *items() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PositionNotify>> *>(VT_ITEMS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RES) &&
           verifier.VerifyTable(res()) &&
           VerifyOffset(verifier, VT_PAGE) &&
           verifier.VerifyTable(page()) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.Verify(items()) &&
           verifier.VerifyVectorOfTables(items()) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           verifier.EndTable();
  }
};

struct Query_position_rspBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_res(flatbuffers::Offset<Result> res) {
    fbb_.AddOffset(Query_position_rsp::VT_RES, res);
  }
  void add_page(flatbuffers::Offset<Query_page> page) {
    fbb_.AddOffset(Query_position_rsp::VT_PAGE, page);
  }
  void add_items(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PositionNotify>>> items) {
    fbb_.AddOffset(Query_position_rsp::VT_ITEMS, items);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(Query_position_rsp::VT_EXTRAS, extras);
  }
  explicit Query_position_rspBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Query_position_rspBuilder &operator=(const Query_position_rspBuilder &);
  flatbuffers::Offset<Query_position_rsp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Query_position_rsp>(end);
    return o;
  }
};

inline flatbuffers::Offset<Query_position_rsp> CreateQuery_position_rsp(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Result> res = 0,
    flatbuffers::Offset<Query_page> page = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PositionNotify>>> items = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0) {
  Query_position_rspBuilder builder_(_fbb);
  builder_.add_extras(extras);
  builder_.add_items(items);
  builder_.add_page(page);
  builder_.add_res(res);
  return builder_.Finish();
}

inline flatbuffers::Offset<Query_position_rsp> CreateQuery_position_rspDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Result> res = 0,
    flatbuffers::Offset<Query_page> page = 0,
    const std::vector<flatbuffers::Offset<PositionNotify>> *items = nullptr,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr) {
  return mm::CreateQuery_position_rsp(
      _fbb,
      res,
      page,
      items ? _fbb.CreateVector<flatbuffers::Offset<PositionNotify>>(*items) : 0,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0);
}

struct Query_settlement FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACC = 4,
    VT_PAGE = 6,
    VT_SETTLEMENT_TYPE = 8,
    VT_DATE_FROM = 10,
    VT_DATE_TO = 12,
    VT_EXTRAS = 14
  };
  const Account *acc() const {
    return GetPointer<const Account *>(VT_ACC);
  }
  const Query_page *page() const {
    return GetPointer<const Query_page *>(VT_PAGE);
  }
  SettleType settlement_type() const {
    return static_cast<SettleType>(GetField<uint8_t>(VT_SETTLEMENT_TYPE, 0));
  }
  const flatbuffers::String *date_from() const {
    return GetPointer<const flatbuffers::String *>(VT_DATE_FROM);
  }
  const flatbuffers::String *date_to() const {
    return GetPointer<const flatbuffers::String *>(VT_DATE_TO);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACC) &&
           verifier.VerifyTable(acc()) &&
           VerifyOffset(verifier, VT_PAGE) &&
           verifier.VerifyTable(page()) &&
           VerifyField<uint8_t>(verifier, VT_SETTLEMENT_TYPE) &&
           VerifyOffset(verifier, VT_DATE_FROM) &&
           verifier.Verify(date_from()) &&
           VerifyOffset(verifier, VT_DATE_TO) &&
           verifier.Verify(date_to()) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           verifier.EndTable();
  }
};

struct Query_settlementBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acc(flatbuffers::Offset<Account> acc) {
    fbb_.AddOffset(Query_settlement::VT_ACC, acc);
  }
  void add_page(flatbuffers::Offset<Query_page> page) {
    fbb_.AddOffset(Query_settlement::VT_PAGE, page);
  }
  void add_settlement_type(SettleType settlement_type) {
    fbb_.AddElement<uint8_t>(Query_settlement::VT_SETTLEMENT_TYPE, static_cast<uint8_t>(settlement_type), 0);
  }
  void add_date_from(flatbuffers::Offset<flatbuffers::String> date_from) {
    fbb_.AddOffset(Query_settlement::VT_DATE_FROM, date_from);
  }
  void add_date_to(flatbuffers::Offset<flatbuffers::String> date_to) {
    fbb_.AddOffset(Query_settlement::VT_DATE_TO, date_to);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(Query_settlement::VT_EXTRAS, extras);
  }
  explicit Query_settlementBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Query_settlementBuilder &operator=(const Query_settlementBuilder &);
  flatbuffers::Offset<Query_settlement> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Query_settlement>(end);
    return o;
  }
};

inline flatbuffers::Offset<Query_settlement> CreateQuery_settlement(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    flatbuffers::Offset<Query_page> page = 0,
    SettleType settlement_type = SettleType_NONE,
    flatbuffers::Offset<flatbuffers::String> date_from = 0,
    flatbuffers::Offset<flatbuffers::String> date_to = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0) {
  Query_settlementBuilder builder_(_fbb);
  builder_.add_extras(extras);
  builder_.add_date_to(date_to);
  builder_.add_date_from(date_from);
  builder_.add_page(page);
  builder_.add_acc(acc);
  builder_.add_settlement_type(settlement_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Query_settlement> CreateQuery_settlementDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    flatbuffers::Offset<Query_page> page = 0,
    SettleType settlement_type = SettleType_NONE,
    const char *date_from = nullptr,
    const char *date_to = nullptr,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr) {
  return mm::CreateQuery_settlement(
      _fbb,
      acc,
      page,
      settlement_type,
      date_from ? _fbb.CreateString(date_from) : 0,
      date_to ? _fbb.CreateString(date_to) : 0,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0);
}

struct Query_settlement_rsp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RES = 4,
    VT_PAGE = 6,
    VT_URLS = 8,
    VT_EXTRAS = 10
  };
  const Result *res() const {
    return GetPointer<const Result *>(VT_RES);
  }
  const Query_page *page() const {
    return GetPointer<const Query_page *>(VT_PAGE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *urls() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_URLS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RES) &&
           verifier.VerifyTable(res()) &&
           VerifyOffset(verifier, VT_PAGE) &&
           verifier.VerifyTable(page()) &&
           VerifyOffset(verifier, VT_URLS) &&
           verifier.Verify(urls()) &&
           verifier.VerifyVectorOfStrings(urls()) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           verifier.EndTable();
  }
};

struct Query_settlement_rspBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_res(flatbuffers::Offset<Result> res) {
    fbb_.AddOffset(Query_settlement_rsp::VT_RES, res);
  }
  void add_page(flatbuffers::Offset<Query_page> page) {
    fbb_.AddOffset(Query_settlement_rsp::VT_PAGE, page);
  }
  void add_urls(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> urls) {
    fbb_.AddOffset(Query_settlement_rsp::VT_URLS, urls);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(Query_settlement_rsp::VT_EXTRAS, extras);
  }
  explicit Query_settlement_rspBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Query_settlement_rspBuilder &operator=(const Query_settlement_rspBuilder &);
  flatbuffers::Offset<Query_settlement_rsp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Query_settlement_rsp>(end);
    return o;
  }
};

inline flatbuffers::Offset<Query_settlement_rsp> CreateQuery_settlement_rsp(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Result> res = 0,
    flatbuffers::Offset<Query_page> page = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> urls = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0) {
  Query_settlement_rspBuilder builder_(_fbb);
  builder_.add_extras(extras);
  builder_.add_urls(urls);
  builder_.add_page(page);
  builder_.add_res(res);
  return builder_.Finish();
}

inline flatbuffers::Offset<Query_settlement_rsp> CreateQuery_settlement_rspDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Result> res = 0,
    flatbuffers::Offset<Query_page> page = 0,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *urls = nullptr,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr) {
  return mm::CreateQuery_settlement_rsp(
      _fbb,
      res,
      page,
      urls ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*urls) : 0,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0);
}

struct Query_maxbuy FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACC = 4,
    VT_MARKET = 6,
    VT_SYMBOL = 8,
    VT_POWER = 10,
    VT_PRICE = 12,
    VT_EXTRAS = 14
  };
  const Account *acc() const {
    return GetPointer<const Account *>(VT_ACC);
  }
  Market market() const {
    return static_cast<Market>(GetField<uint8_t>(VT_MARKET, 0));
  }
  const flatbuffers::String *symbol() const {
    return GetPointer<const flatbuffers::String *>(VT_SYMBOL);
  }
  const flatbuffers::String *power() const {
    return GetPointer<const flatbuffers::String *>(VT_POWER);
  }
  const flatbuffers::String *price() const {
    return GetPointer<const flatbuffers::String *>(VT_PRICE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACC) &&
           verifier.VerifyTable(acc()) &&
           VerifyField<uint8_t>(verifier, VT_MARKET) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.Verify(symbol()) &&
           VerifyOffset(verifier, VT_POWER) &&
           verifier.Verify(power()) &&
           VerifyOffset(verifier, VT_PRICE) &&
           verifier.Verify(price()) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           verifier.EndTable();
  }
};

struct Query_maxbuyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acc(flatbuffers::Offset<Account> acc) {
    fbb_.AddOffset(Query_maxbuy::VT_ACC, acc);
  }
  void add_market(Market market) {
    fbb_.AddElement<uint8_t>(Query_maxbuy::VT_MARKET, static_cast<uint8_t>(market), 0);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) {
    fbb_.AddOffset(Query_maxbuy::VT_SYMBOL, symbol);
  }
  void add_power(flatbuffers::Offset<flatbuffers::String> power) {
    fbb_.AddOffset(Query_maxbuy::VT_POWER, power);
  }
  void add_price(flatbuffers::Offset<flatbuffers::String> price) {
    fbb_.AddOffset(Query_maxbuy::VT_PRICE, price);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(Query_maxbuy::VT_EXTRAS, extras);
  }
  explicit Query_maxbuyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Query_maxbuyBuilder &operator=(const Query_maxbuyBuilder &);
  flatbuffers::Offset<Query_maxbuy> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Query_maxbuy>(end);
    return o;
  }
};

inline flatbuffers::Offset<Query_maxbuy> CreateQuery_maxbuy(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    Market market = Market_NONE,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    flatbuffers::Offset<flatbuffers::String> power = 0,
    flatbuffers::Offset<flatbuffers::String> price = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0) {
  Query_maxbuyBuilder builder_(_fbb);
  builder_.add_extras(extras);
  builder_.add_price(price);
  builder_.add_power(power);
  builder_.add_symbol(symbol);
  builder_.add_acc(acc);
  builder_.add_market(market);
  return builder_.Finish();
}

inline flatbuffers::Offset<Query_maxbuy> CreateQuery_maxbuyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    Market market = Market_NONE,
    const char *symbol = nullptr,
    const char *power = nullptr,
    const char *price = nullptr,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr) {
  return mm::CreateQuery_maxbuy(
      _fbb,
      acc,
      market,
      symbol ? _fbb.CreateString(symbol) : 0,
      power ? _fbb.CreateString(power) : 0,
      price ? _fbb.CreateString(price) : 0,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0);
}

struct Query_maxbuy_rsp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RES = 4,
    VT_QTY = 6,
    VT_EXTRAS = 8
  };
  const Result *res() const {
    return GetPointer<const Result *>(VT_RES);
  }
  const flatbuffers::String *qty() const {
    return GetPointer<const flatbuffers::String *>(VT_QTY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RES) &&
           verifier.VerifyTable(res()) &&
           VerifyOffset(verifier, VT_QTY) &&
           verifier.Verify(qty()) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           verifier.EndTable();
  }
};

struct Query_maxbuy_rspBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_res(flatbuffers::Offset<Result> res) {
    fbb_.AddOffset(Query_maxbuy_rsp::VT_RES, res);
  }
  void add_qty(flatbuffers::Offset<flatbuffers::String> qty) {
    fbb_.AddOffset(Query_maxbuy_rsp::VT_QTY, qty);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(Query_maxbuy_rsp::VT_EXTRAS, extras);
  }
  explicit Query_maxbuy_rspBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Query_maxbuy_rspBuilder &operator=(const Query_maxbuy_rspBuilder &);
  flatbuffers::Offset<Query_maxbuy_rsp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Query_maxbuy_rsp>(end);
    return o;
  }
};

inline flatbuffers::Offset<Query_maxbuy_rsp> CreateQuery_maxbuy_rsp(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Result> res = 0,
    flatbuffers::Offset<flatbuffers::String> qty = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0) {
  Query_maxbuy_rspBuilder builder_(_fbb);
  builder_.add_extras(extras);
  builder_.add_qty(qty);
  builder_.add_res(res);
  return builder_.Finish();
}

inline flatbuffers::Offset<Query_maxbuy_rsp> CreateQuery_maxbuy_rspDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Result> res = 0,
    const char *qty = nullptr,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr) {
  return mm::CreateQuery_maxbuy_rsp(
      _fbb,
      res,
      qty ? _fbb.CreateString(qty) : 0,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0);
}

struct Entrust_rsp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RES = 4,
    VT_ENTRUST = 6,
    VT_EXTRAS = 8
  };
  const Result *res() const {
    return GetPointer<const Result *>(VT_RES);
  }
  const Entrust *entrust() const {
    return GetPointer<const Entrust *>(VT_ENTRUST);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RES) &&
           verifier.VerifyTable(res()) &&
           VerifyOffset(verifier, VT_ENTRUST) &&
           verifier.VerifyTable(entrust()) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           verifier.EndTable();
  }
};

struct Entrust_rspBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_res(flatbuffers::Offset<Result> res) {
    fbb_.AddOffset(Entrust_rsp::VT_RES, res);
  }
  void add_entrust(flatbuffers::Offset<Entrust> entrust) {
    fbb_.AddOffset(Entrust_rsp::VT_ENTRUST, entrust);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(Entrust_rsp::VT_EXTRAS, extras);
  }
  explicit Entrust_rspBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Entrust_rspBuilder &operator=(const Entrust_rspBuilder &);
  flatbuffers::Offset<Entrust_rsp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Entrust_rsp>(end);
    return o;
  }
};

inline flatbuffers::Offset<Entrust_rsp> CreateEntrust_rsp(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Result> res = 0,
    flatbuffers::Offset<Entrust> entrust = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0) {
  Entrust_rspBuilder builder_(_fbb);
  builder_.add_extras(extras);
  builder_.add_entrust(entrust);
  builder_.add_res(res);
  return builder_.Finish();
}

inline flatbuffers::Offset<Entrust_rsp> CreateEntrust_rspDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Result> res = 0,
    flatbuffers::Offset<Entrust> entrust = 0,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr) {
  return mm::CreateEntrust_rsp(
      _fbb,
      res,
      entrust,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0);
}

struct EntrustAll FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACC = 4,
    VT_MARKET = 6
  };
  const Account *acc() const {
    return GetPointer<const Account *>(VT_ACC);
  }
  Market market() const {
    return static_cast<Market>(GetField<uint8_t>(VT_MARKET, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACC) &&
           verifier.VerifyTable(acc()) &&
           VerifyField<uint8_t>(verifier, VT_MARKET) &&
           verifier.EndTable();
  }
};

struct EntrustAllBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acc(flatbuffers::Offset<Account> acc) {
    fbb_.AddOffset(EntrustAll::VT_ACC, acc);
  }
  void add_market(Market market) {
    fbb_.AddElement<uint8_t>(EntrustAll::VT_MARKET, static_cast<uint8_t>(market), 0);
  }
  explicit EntrustAllBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EntrustAllBuilder &operator=(const EntrustAllBuilder &);
  flatbuffers::Offset<EntrustAll> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EntrustAll>(end);
    return o;
  }
};

inline flatbuffers::Offset<EntrustAll> CreateEntrustAll(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    Market market = Market_NONE) {
  EntrustAllBuilder builder_(_fbb);
  builder_.add_acc(acc);
  builder_.add_market(market);
  return builder_.Finish();
}

struct Exrate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CCY = 4,
    VT_RATE = 6
  };
  Currency ccy() const {
    return static_cast<Currency>(GetField<uint8_t>(VT_CCY, 0));
  }
  const flatbuffers::String *rate() const {
    return GetPointer<const flatbuffers::String *>(VT_RATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CCY) &&
           VerifyOffset(verifier, VT_RATE) &&
           verifier.Verify(rate()) &&
           verifier.EndTable();
  }
};

struct ExrateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ccy(Currency ccy) {
    fbb_.AddElement<uint8_t>(Exrate::VT_CCY, static_cast<uint8_t>(ccy), 0);
  }
  void add_rate(flatbuffers::Offset<flatbuffers::String> rate) {
    fbb_.AddOffset(Exrate::VT_RATE, rate);
  }
  explicit ExrateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExrateBuilder &operator=(const ExrateBuilder &);
  flatbuffers::Offset<Exrate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Exrate>(end);
    return o;
  }
};

inline flatbuffers::Offset<Exrate> CreateExrate(
    flatbuffers::FlatBufferBuilder &_fbb,
    Currency ccy = Currency_NONE,
    flatbuffers::Offset<flatbuffers::String> rate = 0) {
  ExrateBuilder builder_(_fbb);
  builder_.add_rate(rate);
  builder_.add_ccy(ccy);
  return builder_.Finish();
}

inline flatbuffers::Offset<Exrate> CreateExrateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Currency ccy = Currency_NONE,
    const char *rate = nullptr) {
  return mm::CreateExrate(
      _fbb,
      ccy,
      rate ? _fbb.CreateString(rate) : 0);
}

struct Exrates FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CCY = 4,
    VT_RATES = 6
  };
  Currency ccy() const {
    return static_cast<Currency>(GetField<uint8_t>(VT_CCY, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<Exrate>> *rates() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Exrate>> *>(VT_RATES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CCY) &&
           VerifyOffset(verifier, VT_RATES) &&
           verifier.Verify(rates()) &&
           verifier.VerifyVectorOfTables(rates()) &&
           verifier.EndTable();
  }
};

struct ExratesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ccy(Currency ccy) {
    fbb_.AddElement<uint8_t>(Exrates::VT_CCY, static_cast<uint8_t>(ccy), 0);
  }
  void add_rates(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Exrate>>> rates) {
    fbb_.AddOffset(Exrates::VT_RATES, rates);
  }
  explicit ExratesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExratesBuilder &operator=(const ExratesBuilder &);
  flatbuffers::Offset<Exrates> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Exrates>(end);
    return o;
  }
};

inline flatbuffers::Offset<Exrates> CreateExrates(
    flatbuffers::FlatBufferBuilder &_fbb,
    Currency ccy = Currency_NONE,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Exrate>>> rates = 0) {
  ExratesBuilder builder_(_fbb);
  builder_.add_rates(rates);
  builder_.add_ccy(ccy);
  return builder_.Finish();
}

inline flatbuffers::Offset<Exrates> CreateExratesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Currency ccy = Currency_NONE,
    const std::vector<flatbuffers::Offset<Exrate>> *rates = nullptr) {
  return mm::CreateExrates(
      _fbb,
      ccy,
      rates ? _fbb.CreateVector<flatbuffers::Offset<Exrate>>(*rates) : 0);
}

struct Product FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MARKET = 4,
    VT_SYMBOL = 6,
    VT_PRODUCT_TYPE = 8,
    VT_PRODUCT_SUB_TYPE = 10,
    VT_SHORT_NAME = 12,
    VT_NAME = 14,
    VT_STATUS = 16,
    VT_LOT_SIZE = 18,
    VT_PS_CODE = 20,
    VT_CONTRACT_SIZE = 22,
    VT_PRODUCT_GROUP = 24,
    VT_CONTRACT_MONTH = 26,
    VT_EXPIRE_DATE = 28,
    VT_LAST_TRADING_DATE = 30,
    VT_CCY = 32,
    VT_STRIKE_PRICE = 34,
    VT_PRICE_FACTOR = 36,
    VT_PRICE_DENOMINATOR = 38,
    VT_LOAN_PERCENT = 40,
    VT_DISALLOW_BUY = 42,
    VT_DISALLOW_SELL = 44,
    VT_DISALLOW_SHORTSELL = 46,
    VT_EXTRAS = 48,
    VT_EXPIRE_NOTIFY_DAY = 50,
    VT_IM_RATIO = 52,
    VT_MM_RATIO = 54,
    VT_MMARGIN = 56,
    VT_MARGIN_MODE = 58
  };
  Market market() const {
    return static_cast<Market>(GetField<uint8_t>(VT_MARKET, 0));
  }
  const flatbuffers::String *symbol() const {
    return GetPointer<const flatbuffers::String *>(VT_SYMBOL);
  }
  ProductType product_type() const {
    return static_cast<ProductType>(GetField<uint8_t>(VT_PRODUCT_TYPE, 0));
  }
  ProductSubType product_sub_type() const {
    return static_cast<ProductSubType>(GetField<uint8_t>(VT_PRODUCT_SUB_TYPE, 0));
  }
  const flatbuffers::String *short_name() const {
    return GetPointer<const flatbuffers::String *>(VT_SHORT_NAME);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  Status status() const {
    return static_cast<Status>(GetField<uint8_t>(VT_STATUS, 0));
  }
  const flatbuffers::String *lot_size() const {
    return GetPointer<const flatbuffers::String *>(VT_LOT_SIZE);
  }
  const flatbuffers::String *ps_code() const {
    return GetPointer<const flatbuffers::String *>(VT_PS_CODE);
  }
  uint64_t contract_size() const {
    return GetField<uint64_t>(VT_CONTRACT_SIZE, 0);
  }
  const flatbuffers::String *product_group() const {
    return GetPointer<const flatbuffers::String *>(VT_PRODUCT_GROUP);
  }
  const flatbuffers::String *contract_month() const {
    return GetPointer<const flatbuffers::String *>(VT_CONTRACT_MONTH);
  }
  const flatbuffers::String *expire_date() const {
    return GetPointer<const flatbuffers::String *>(VT_EXPIRE_DATE);
  }
  const flatbuffers::String *last_trading_date() const {
    return GetPointer<const flatbuffers::String *>(VT_LAST_TRADING_DATE);
  }
  Currency ccy() const {
    return static_cast<Currency>(GetField<uint8_t>(VT_CCY, 0));
  }
  const flatbuffers::String *strike_price() const {
    return GetPointer<const flatbuffers::String *>(VT_STRIKE_PRICE);
  }
  uint64_t price_factor() const {
    return GetField<uint64_t>(VT_PRICE_FACTOR, 0);
  }
  uint64_t price_denominator() const {
    return GetField<uint64_t>(VT_PRICE_DENOMINATOR, 0);
  }
  uint16_t loan_percent() const {
    return GetField<uint16_t>(VT_LOAN_PERCENT, 0);
  }
  uint8_t disallow_buy() const {
    return GetField<uint8_t>(VT_DISALLOW_BUY, 0);
  }
  uint8_t disallow_sell() const {
    return GetField<uint8_t>(VT_DISALLOW_SELL, 0);
  }
  uint8_t disallow_shortsell() const {
    return GetField<uint8_t>(VT_DISALLOW_SHORTSELL, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  uint64_t expire_notify_day() const {
    return GetField<uint64_t>(VT_EXPIRE_NOTIFY_DAY, 0);
  }
  const flatbuffers::String *im_ratio() const {
    return GetPointer<const flatbuffers::String *>(VT_IM_RATIO);
  }
  const flatbuffers::String *mm_ratio() const {
    return GetPointer<const flatbuffers::String *>(VT_MM_RATIO);
  }
  const flatbuffers::String *mmargin() const {
    return GetPointer<const flatbuffers::String *>(VT_MMARGIN);
  }
  MarginMode margin_mode() const {
    return static_cast<MarginMode>(GetField<uint8_t>(VT_MARGIN_MODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MARKET) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.Verify(symbol()) &&
           VerifyField<uint8_t>(verifier, VT_PRODUCT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_PRODUCT_SUB_TYPE) &&
           VerifyOffset(verifier, VT_SHORT_NAME) &&
           verifier.Verify(short_name()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<uint8_t>(verifier, VT_STATUS) &&
           VerifyOffset(verifier, VT_LOT_SIZE) &&
           verifier.Verify(lot_size()) &&
           VerifyOffset(verifier, VT_PS_CODE) &&
           verifier.Verify(ps_code()) &&
           VerifyField<uint64_t>(verifier, VT_CONTRACT_SIZE) &&
           VerifyOffset(verifier, VT_PRODUCT_GROUP) &&
           verifier.Verify(product_group()) &&
           VerifyOffset(verifier, VT_CONTRACT_MONTH) &&
           verifier.Verify(contract_month()) &&
           VerifyOffset(verifier, VT_EXPIRE_DATE) &&
           verifier.Verify(expire_date()) &&
           VerifyOffset(verifier, VT_LAST_TRADING_DATE) &&
           verifier.Verify(last_trading_date()) &&
           VerifyField<uint8_t>(verifier, VT_CCY) &&
           VerifyOffset(verifier, VT_STRIKE_PRICE) &&
           verifier.Verify(strike_price()) &&
           VerifyField<uint64_t>(verifier, VT_PRICE_FACTOR) &&
           VerifyField<uint64_t>(verifier, VT_PRICE_DENOMINATOR) &&
           VerifyField<uint16_t>(verifier, VT_LOAN_PERCENT) &&
           VerifyField<uint8_t>(verifier, VT_DISALLOW_BUY) &&
           VerifyField<uint8_t>(verifier, VT_DISALLOW_SELL) &&
           VerifyField<uint8_t>(verifier, VT_DISALLOW_SHORTSELL) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           VerifyField<uint64_t>(verifier, VT_EXPIRE_NOTIFY_DAY) &&
           VerifyOffset(verifier, VT_IM_RATIO) &&
           verifier.Verify(im_ratio()) &&
           VerifyOffset(verifier, VT_MM_RATIO) &&
           verifier.Verify(mm_ratio()) &&
           VerifyOffset(verifier, VT_MMARGIN) &&
           verifier.Verify(mmargin()) &&
           VerifyField<uint8_t>(verifier, VT_MARGIN_MODE) &&
           verifier.EndTable();
  }
};

struct ProductBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_market(Market market) {
    fbb_.AddElement<uint8_t>(Product::VT_MARKET, static_cast<uint8_t>(market), 0);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) {
    fbb_.AddOffset(Product::VT_SYMBOL, symbol);
  }
  void add_product_type(ProductType product_type) {
    fbb_.AddElement<uint8_t>(Product::VT_PRODUCT_TYPE, static_cast<uint8_t>(product_type), 0);
  }
  void add_product_sub_type(ProductSubType product_sub_type) {
    fbb_.AddElement<uint8_t>(Product::VT_PRODUCT_SUB_TYPE, static_cast<uint8_t>(product_sub_type), 0);
  }
  void add_short_name(flatbuffers::Offset<flatbuffers::String> short_name) {
    fbb_.AddOffset(Product::VT_SHORT_NAME, short_name);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Product::VT_NAME, name);
  }
  void add_status(Status status) {
    fbb_.AddElement<uint8_t>(Product::VT_STATUS, static_cast<uint8_t>(status), 0);
  }
  void add_lot_size(flatbuffers::Offset<flatbuffers::String> lot_size) {
    fbb_.AddOffset(Product::VT_LOT_SIZE, lot_size);
  }
  void add_ps_code(flatbuffers::Offset<flatbuffers::String> ps_code) {
    fbb_.AddOffset(Product::VT_PS_CODE, ps_code);
  }
  void add_contract_size(uint64_t contract_size) {
    fbb_.AddElement<uint64_t>(Product::VT_CONTRACT_SIZE, contract_size, 0);
  }
  void add_product_group(flatbuffers::Offset<flatbuffers::String> product_group) {
    fbb_.AddOffset(Product::VT_PRODUCT_GROUP, product_group);
  }
  void add_contract_month(flatbuffers::Offset<flatbuffers::String> contract_month) {
    fbb_.AddOffset(Product::VT_CONTRACT_MONTH, contract_month);
  }
  void add_expire_date(flatbuffers::Offset<flatbuffers::String> expire_date) {
    fbb_.AddOffset(Product::VT_EXPIRE_DATE, expire_date);
  }
  void add_last_trading_date(flatbuffers::Offset<flatbuffers::String> last_trading_date) {
    fbb_.AddOffset(Product::VT_LAST_TRADING_DATE, last_trading_date);
  }
  void add_ccy(Currency ccy) {
    fbb_.AddElement<uint8_t>(Product::VT_CCY, static_cast<uint8_t>(ccy), 0);
  }
  void add_strike_price(flatbuffers::Offset<flatbuffers::String> strike_price) {
    fbb_.AddOffset(Product::VT_STRIKE_PRICE, strike_price);
  }
  void add_price_factor(uint64_t price_factor) {
    fbb_.AddElement<uint64_t>(Product::VT_PRICE_FACTOR, price_factor, 0);
  }
  void add_price_denominator(uint64_t price_denominator) {
    fbb_.AddElement<uint64_t>(Product::VT_PRICE_DENOMINATOR, price_denominator, 0);
  }
  void add_loan_percent(uint16_t loan_percent) {
    fbb_.AddElement<uint16_t>(Product::VT_LOAN_PERCENT, loan_percent, 0);
  }
  void add_disallow_buy(uint8_t disallow_buy) {
    fbb_.AddElement<uint8_t>(Product::VT_DISALLOW_BUY, disallow_buy, 0);
  }
  void add_disallow_sell(uint8_t disallow_sell) {
    fbb_.AddElement<uint8_t>(Product::VT_DISALLOW_SELL, disallow_sell, 0);
  }
  void add_disallow_shortsell(uint8_t disallow_shortsell) {
    fbb_.AddElement<uint8_t>(Product::VT_DISALLOW_SHORTSELL, disallow_shortsell, 0);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(Product::VT_EXTRAS, extras);
  }
  void add_expire_notify_day(uint64_t expire_notify_day) {
    fbb_.AddElement<uint64_t>(Product::VT_EXPIRE_NOTIFY_DAY, expire_notify_day, 0);
  }
  void add_im_ratio(flatbuffers::Offset<flatbuffers::String> im_ratio) {
    fbb_.AddOffset(Product::VT_IM_RATIO, im_ratio);
  }
  void add_mm_ratio(flatbuffers::Offset<flatbuffers::String> mm_ratio) {
    fbb_.AddOffset(Product::VT_MM_RATIO, mm_ratio);
  }
  void add_mmargin(flatbuffers::Offset<flatbuffers::String> mmargin) {
    fbb_.AddOffset(Product::VT_MMARGIN, mmargin);
  }
  void add_margin_mode(MarginMode margin_mode) {
    fbb_.AddElement<uint8_t>(Product::VT_MARGIN_MODE, static_cast<uint8_t>(margin_mode), 0);
  }
  explicit ProductBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProductBuilder &operator=(const ProductBuilder &);
  flatbuffers::Offset<Product> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Product>(end);
    return o;
  }
};

inline flatbuffers::Offset<Product> CreateProduct(
    flatbuffers::FlatBufferBuilder &_fbb,
    Market market = Market_NONE,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    ProductType product_type = ProductType_NONE,
    ProductSubType product_sub_type = ProductSubType_NONE,
    flatbuffers::Offset<flatbuffers::String> short_name = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    Status status = Status_NONE,
    flatbuffers::Offset<flatbuffers::String> lot_size = 0,
    flatbuffers::Offset<flatbuffers::String> ps_code = 0,
    uint64_t contract_size = 0,
    flatbuffers::Offset<flatbuffers::String> product_group = 0,
    flatbuffers::Offset<flatbuffers::String> contract_month = 0,
    flatbuffers::Offset<flatbuffers::String> expire_date = 0,
    flatbuffers::Offset<flatbuffers::String> last_trading_date = 0,
    Currency ccy = Currency_NONE,
    flatbuffers::Offset<flatbuffers::String> strike_price = 0,
    uint64_t price_factor = 0,
    uint64_t price_denominator = 0,
    uint16_t loan_percent = 0,
    uint8_t disallow_buy = 0,
    uint8_t disallow_sell = 0,
    uint8_t disallow_shortsell = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0,
    uint64_t expire_notify_day = 0,
    flatbuffers::Offset<flatbuffers::String> im_ratio = 0,
    flatbuffers::Offset<flatbuffers::String> mm_ratio = 0,
    flatbuffers::Offset<flatbuffers::String> mmargin = 0,
    MarginMode margin_mode = MarginMode_SPAN) {
  ProductBuilder builder_(_fbb);
  builder_.add_expire_notify_day(expire_notify_day);
  builder_.add_price_denominator(price_denominator);
  builder_.add_price_factor(price_factor);
  builder_.add_contract_size(contract_size);
  builder_.add_mmargin(mmargin);
  builder_.add_mm_ratio(mm_ratio);
  builder_.add_im_ratio(im_ratio);
  builder_.add_extras(extras);
  builder_.add_strike_price(strike_price);
  builder_.add_last_trading_date(last_trading_date);
  builder_.add_expire_date(expire_date);
  builder_.add_contract_month(contract_month);
  builder_.add_product_group(product_group);
  builder_.add_ps_code(ps_code);
  builder_.add_lot_size(lot_size);
  builder_.add_name(name);
  builder_.add_short_name(short_name);
  builder_.add_symbol(symbol);
  builder_.add_loan_percent(loan_percent);
  builder_.add_margin_mode(margin_mode);
  builder_.add_disallow_shortsell(disallow_shortsell);
  builder_.add_disallow_sell(disallow_sell);
  builder_.add_disallow_buy(disallow_buy);
  builder_.add_ccy(ccy);
  builder_.add_status(status);
  builder_.add_product_sub_type(product_sub_type);
  builder_.add_product_type(product_type);
  builder_.add_market(market);
  return builder_.Finish();
}

inline flatbuffers::Offset<Product> CreateProductDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Market market = Market_NONE,
    const char *symbol = nullptr,
    ProductType product_type = ProductType_NONE,
    ProductSubType product_sub_type = ProductSubType_NONE,
    const char *short_name = nullptr,
    const char *name = nullptr,
    Status status = Status_NONE,
    const char *lot_size = nullptr,
    const char *ps_code = nullptr,
    uint64_t contract_size = 0,
    const char *product_group = nullptr,
    const char *contract_month = nullptr,
    const char *expire_date = nullptr,
    const char *last_trading_date = nullptr,
    Currency ccy = Currency_NONE,
    const char *strike_price = nullptr,
    uint64_t price_factor = 0,
    uint64_t price_denominator = 0,
    uint16_t loan_percent = 0,
    uint8_t disallow_buy = 0,
    uint8_t disallow_sell = 0,
    uint8_t disallow_shortsell = 0,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr,
    uint64_t expire_notify_day = 0,
    const char *im_ratio = nullptr,
    const char *mm_ratio = nullptr,
    const char *mmargin = nullptr,
    MarginMode margin_mode = MarginMode_SPAN) {
  return mm::CreateProduct(
      _fbb,
      market,
      symbol ? _fbb.CreateString(symbol) : 0,
      product_type,
      product_sub_type,
      short_name ? _fbb.CreateString(short_name) : 0,
      name ? _fbb.CreateString(name) : 0,
      status,
      lot_size ? _fbb.CreateString(lot_size) : 0,
      ps_code ? _fbb.CreateString(ps_code) : 0,
      contract_size,
      product_group ? _fbb.CreateString(product_group) : 0,
      contract_month ? _fbb.CreateString(contract_month) : 0,
      expire_date ? _fbb.CreateString(expire_date) : 0,
      last_trading_date ? _fbb.CreateString(last_trading_date) : 0,
      ccy,
      strike_price ? _fbb.CreateString(strike_price) : 0,
      price_factor,
      price_denominator,
      loan_percent,
      disallow_buy,
      disallow_sell,
      disallow_shortsell,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0,
      expire_notify_day,
      im_ratio ? _fbb.CreateString(im_ratio) : 0,
      mm_ratio ? _fbb.CreateString(mm_ratio) : 0,
      mmargin ? _fbb.CreateString(mmargin) : 0,
      margin_mode);
}

struct Product_rsp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RES = 4,
    VT_PRODUCT = 6
  };
  const Result *res() const {
    return GetPointer<const Result *>(VT_RES);
  }
  const Product *product() const {
    return GetPointer<const Product *>(VT_PRODUCT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RES) &&
           verifier.VerifyTable(res()) &&
           VerifyOffset(verifier, VT_PRODUCT) &&
           verifier.VerifyTable(product()) &&
           verifier.EndTable();
  }
};

struct Product_rspBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_res(flatbuffers::Offset<Result> res) {
    fbb_.AddOffset(Product_rsp::VT_RES, res);
  }
  void add_product(flatbuffers::Offset<Product> product) {
    fbb_.AddOffset(Product_rsp::VT_PRODUCT, product);
  }
  explicit Product_rspBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Product_rspBuilder &operator=(const Product_rspBuilder &);
  flatbuffers::Offset<Product_rsp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Product_rsp>(end);
    return o;
  }
};

inline flatbuffers::Offset<Product_rsp> CreateProduct_rsp(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Result> res = 0,
    flatbuffers::Offset<Product> product = 0) {
  Product_rspBuilder builder_(_fbb);
  builder_.add_product(product);
  builder_.add_res(res);
  return builder_.Finish();
}

struct Query_products FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACC = 4,
    VT_PAGE = 6
  };
  const Account *acc() const {
    return GetPointer<const Account *>(VT_ACC);
  }
  const Query_page *page() const {
    return GetPointer<const Query_page *>(VT_PAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACC) &&
           verifier.VerifyTable(acc()) &&
           VerifyOffset(verifier, VT_PAGE) &&
           verifier.VerifyTable(page()) &&
           verifier.EndTable();
  }
};

struct Query_productsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acc(flatbuffers::Offset<Account> acc) {
    fbb_.AddOffset(Query_products::VT_ACC, acc);
  }
  void add_page(flatbuffers::Offset<Query_page> page) {
    fbb_.AddOffset(Query_products::VT_PAGE, page);
  }
  explicit Query_productsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Query_productsBuilder &operator=(const Query_productsBuilder &);
  flatbuffers::Offset<Query_products> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Query_products>(end);
    return o;
  }
};

inline flatbuffers::Offset<Query_products> CreateQuery_products(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    flatbuffers::Offset<Query_page> page = 0) {
  Query_productsBuilder builder_(_fbb);
  builder_.add_page(page);
  builder_.add_acc(acc);
  return builder_.Finish();
}

struct Query_products_rsp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RSP = 4,
    VT_ACC = 6,
    VT_PAGE = 8,
    VT_ITEMS = 10,
    VT_EXTRAS = 12
  };
  const Result *rsp() const {
    return GetPointer<const Result *>(VT_RSP);
  }
  const Account *acc() const {
    return GetPointer<const Account *>(VT_ACC);
  }
  const Query_page *page() const {
    return GetPointer<const Query_page *>(VT_PAGE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Product>> *items() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Product>> *>(VT_ITEMS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RSP) &&
           verifier.VerifyTable(rsp()) &&
           VerifyOffset(verifier, VT_ACC) &&
           verifier.VerifyTable(acc()) &&
           VerifyOffset(verifier, VT_PAGE) &&
           verifier.VerifyTable(page()) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.Verify(items()) &&
           verifier.VerifyVectorOfTables(items()) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           verifier.EndTable();
  }
};

struct Query_products_rspBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rsp(flatbuffers::Offset<Result> rsp) {
    fbb_.AddOffset(Query_products_rsp::VT_RSP, rsp);
  }
  void add_acc(flatbuffers::Offset<Account> acc) {
    fbb_.AddOffset(Query_products_rsp::VT_ACC, acc);
  }
  void add_page(flatbuffers::Offset<Query_page> page) {
    fbb_.AddOffset(Query_products_rsp::VT_PAGE, page);
  }
  void add_items(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Product>>> items) {
    fbb_.AddOffset(Query_products_rsp::VT_ITEMS, items);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(Query_products_rsp::VT_EXTRAS, extras);
  }
  explicit Query_products_rspBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Query_products_rspBuilder &operator=(const Query_products_rspBuilder &);
  flatbuffers::Offset<Query_products_rsp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Query_products_rsp>(end);
    return o;
  }
};

inline flatbuffers::Offset<Query_products_rsp> CreateQuery_products_rsp(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Result> rsp = 0,
    flatbuffers::Offset<Account> acc = 0,
    flatbuffers::Offset<Query_page> page = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Product>>> items = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0) {
  Query_products_rspBuilder builder_(_fbb);
  builder_.add_extras(extras);
  builder_.add_items(items);
  builder_.add_page(page);
  builder_.add_acc(acc);
  builder_.add_rsp(rsp);
  return builder_.Finish();
}

inline flatbuffers::Offset<Query_products_rsp> CreateQuery_products_rspDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Result> rsp = 0,
    flatbuffers::Offset<Account> acc = 0,
    flatbuffers::Offset<Query_page> page = 0,
    const std::vector<flatbuffers::Offset<Product>> *items = nullptr,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr) {
  return mm::CreateQuery_products_rsp(
      _fbb,
      rsp,
      acc,
      page,
      items ? _fbb.CreateVector<flatbuffers::Offset<Product>>(*items) : 0,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0);
}

struct MarginScalingClassDetail FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIME_INTERVAL = 4,
    VT_PRODUCT_GROUPS = 6,
    VT_SCALING_RATIO = 8
  };
  const flatbuffers::String *time_interval() const {
    return GetPointer<const flatbuffers::String *>(VT_TIME_INTERVAL);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *product_groups() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_PRODUCT_GROUPS);
  }
  const flatbuffers::String *scaling_ratio() const {
    return GetPointer<const flatbuffers::String *>(VT_SCALING_RATIO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TIME_INTERVAL) &&
           verifier.Verify(time_interval()) &&
           VerifyOffset(verifier, VT_PRODUCT_GROUPS) &&
           verifier.Verify(product_groups()) &&
           verifier.VerifyVectorOfStrings(product_groups()) &&
           VerifyOffset(verifier, VT_SCALING_RATIO) &&
           verifier.Verify(scaling_ratio()) &&
           verifier.EndTable();
  }
};

struct MarginScalingClassDetailBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time_interval(flatbuffers::Offset<flatbuffers::String> time_interval) {
    fbb_.AddOffset(MarginScalingClassDetail::VT_TIME_INTERVAL, time_interval);
  }
  void add_product_groups(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> product_groups) {
    fbb_.AddOffset(MarginScalingClassDetail::VT_PRODUCT_GROUPS, product_groups);
  }
  void add_scaling_ratio(flatbuffers::Offset<flatbuffers::String> scaling_ratio) {
    fbb_.AddOffset(MarginScalingClassDetail::VT_SCALING_RATIO, scaling_ratio);
  }
  explicit MarginScalingClassDetailBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MarginScalingClassDetailBuilder &operator=(const MarginScalingClassDetailBuilder &);
  flatbuffers::Offset<MarginScalingClassDetail> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MarginScalingClassDetail>(end);
    return o;
  }
};

inline flatbuffers::Offset<MarginScalingClassDetail> CreateMarginScalingClassDetail(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> time_interval = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> product_groups = 0,
    flatbuffers::Offset<flatbuffers::String> scaling_ratio = 0) {
  MarginScalingClassDetailBuilder builder_(_fbb);
  builder_.add_scaling_ratio(scaling_ratio);
  builder_.add_product_groups(product_groups);
  builder_.add_time_interval(time_interval);
  return builder_.Finish();
}

inline flatbuffers::Offset<MarginScalingClassDetail> CreateMarginScalingClassDetailDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *time_interval = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *product_groups = nullptr,
    const char *scaling_ratio = nullptr) {
  return mm::CreateMarginScalingClassDetail(
      _fbb,
      time_interval ? _fbb.CreateString(time_interval) : 0,
      product_groups ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*product_groups) : 0,
      scaling_ratio ? _fbb.CreateString(scaling_ratio) : 0);
}

struct MarginScalingClass FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CODE = 4,
    VT_DETAILS = 6
  };
  const flatbuffers::String *code() const {
    return GetPointer<const flatbuffers::String *>(VT_CODE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<MarginScalingClassDetail>> *details() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MarginScalingClassDetail>> *>(VT_DETAILS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CODE) &&
           verifier.Verify(code()) &&
           VerifyOffset(verifier, VT_DETAILS) &&
           verifier.Verify(details()) &&
           verifier.VerifyVectorOfTables(details()) &&
           verifier.EndTable();
  }
};

struct MarginScalingClassBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(flatbuffers::Offset<flatbuffers::String> code) {
    fbb_.AddOffset(MarginScalingClass::VT_CODE, code);
  }
  void add_details(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MarginScalingClassDetail>>> details) {
    fbb_.AddOffset(MarginScalingClass::VT_DETAILS, details);
  }
  explicit MarginScalingClassBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MarginScalingClassBuilder &operator=(const MarginScalingClassBuilder &);
  flatbuffers::Offset<MarginScalingClass> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MarginScalingClass>(end);
    return o;
  }
};

inline flatbuffers::Offset<MarginScalingClass> CreateMarginScalingClass(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> code = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MarginScalingClassDetail>>> details = 0) {
  MarginScalingClassBuilder builder_(_fbb);
  builder_.add_details(details);
  builder_.add_code(code);
  return builder_.Finish();
}

inline flatbuffers::Offset<MarginScalingClass> CreateMarginScalingClassDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *code = nullptr,
    const std::vector<flatbuffers::Offset<MarginScalingClassDetail>> *details = nullptr) {
  return mm::CreateMarginScalingClass(
      _fbb,
      code ? _fbb.CreateString(code) : 0,
      details ? _fbb.CreateVector<flatbuffers::Offset<MarginScalingClassDetail>>(*details) : 0);
}

struct AccountInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACC = 4,
    VT_MARKETS = 6,
    VT_ENG_NAME = 8,
    VT_CHT_NAME = 10,
    VT_CHS_NAME = 12,
    VT_FAX = 14,
    VT_TEL = 16,
    VT_ADDRESS = 18,
    VT_STATUS = 20,
    VT_OPEN_DATE = 22,
    VT_EXTRA_BUYING_POWER = 24,
    VT_BANKIDS = 26,
    VT_EXTRAS = 28,
    VT_CREDIT_VALUE = 30,
    VT_MARGIN_SCALE_CODE = 32
  };
  const Account *acc() const {
    return GetPointer<const Account *>(VT_ACC);
  }
  const flatbuffers::Vector<uint8_t> *markets() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_MARKETS);
  }
  const flatbuffers::String *eng_name() const {
    return GetPointer<const flatbuffers::String *>(VT_ENG_NAME);
  }
  const flatbuffers::String *cht_name() const {
    return GetPointer<const flatbuffers::String *>(VT_CHT_NAME);
  }
  const flatbuffers::String *chs_name() const {
    return GetPointer<const flatbuffers::String *>(VT_CHS_NAME);
  }
  const flatbuffers::String *fax() const {
    return GetPointer<const flatbuffers::String *>(VT_FAX);
  }
  const flatbuffers::String *tel() const {
    return GetPointer<const flatbuffers::String *>(VT_TEL);
  }
  const flatbuffers::String *address() const {
    return GetPointer<const flatbuffers::String *>(VT_ADDRESS);
  }
  Status status() const {
    return static_cast<Status>(GetField<uint8_t>(VT_STATUS, 0));
  }
  const flatbuffers::String *open_date() const {
    return GetPointer<const flatbuffers::String *>(VT_OPEN_DATE);
  }
  const flatbuffers::String *extra_buying_power() const {
    return GetPointer<const flatbuffers::String *>(VT_EXTRA_BUYING_POWER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Bank>> *bankids() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Bank>> *>(VT_BANKIDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  const flatbuffers::String *credit_value() const {
    return GetPointer<const flatbuffers::String *>(VT_CREDIT_VALUE);
  }
  const flatbuffers::String *margin_scale_code() const {
    return GetPointer<const flatbuffers::String *>(VT_MARGIN_SCALE_CODE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACC) &&
           verifier.VerifyTable(acc()) &&
           VerifyOffset(verifier, VT_MARKETS) &&
           verifier.Verify(markets()) &&
           VerifyOffset(verifier, VT_ENG_NAME) &&
           verifier.Verify(eng_name()) &&
           VerifyOffset(verifier, VT_CHT_NAME) &&
           verifier.Verify(cht_name()) &&
           VerifyOffset(verifier, VT_CHS_NAME) &&
           verifier.Verify(chs_name()) &&
           VerifyOffset(verifier, VT_FAX) &&
           verifier.Verify(fax()) &&
           VerifyOffset(verifier, VT_TEL) &&
           verifier.Verify(tel()) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.Verify(address()) &&
           VerifyField<uint8_t>(verifier, VT_STATUS) &&
           VerifyOffset(verifier, VT_OPEN_DATE) &&
           verifier.Verify(open_date()) &&
           VerifyOffset(verifier, VT_EXTRA_BUYING_POWER) &&
           verifier.Verify(extra_buying_power()) &&
           VerifyOffset(verifier, VT_BANKIDS) &&
           verifier.Verify(bankids()) &&
           verifier.VerifyVectorOfTables(bankids()) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           VerifyOffset(verifier, VT_CREDIT_VALUE) &&
           verifier.Verify(credit_value()) &&
           VerifyOffset(verifier, VT_MARGIN_SCALE_CODE) &&
           verifier.Verify(margin_scale_code()) &&
           verifier.EndTable();
  }
};

struct AccountInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acc(flatbuffers::Offset<Account> acc) {
    fbb_.AddOffset(AccountInfo::VT_ACC, acc);
  }
  void add_markets(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> markets) {
    fbb_.AddOffset(AccountInfo::VT_MARKETS, markets);
  }
  void add_eng_name(flatbuffers::Offset<flatbuffers::String> eng_name) {
    fbb_.AddOffset(AccountInfo::VT_ENG_NAME, eng_name);
  }
  void add_cht_name(flatbuffers::Offset<flatbuffers::String> cht_name) {
    fbb_.AddOffset(AccountInfo::VT_CHT_NAME, cht_name);
  }
  void add_chs_name(flatbuffers::Offset<flatbuffers::String> chs_name) {
    fbb_.AddOffset(AccountInfo::VT_CHS_NAME, chs_name);
  }
  void add_fax(flatbuffers::Offset<flatbuffers::String> fax) {
    fbb_.AddOffset(AccountInfo::VT_FAX, fax);
  }
  void add_tel(flatbuffers::Offset<flatbuffers::String> tel) {
    fbb_.AddOffset(AccountInfo::VT_TEL, tel);
  }
  void add_address(flatbuffers::Offset<flatbuffers::String> address) {
    fbb_.AddOffset(AccountInfo::VT_ADDRESS, address);
  }
  void add_status(Status status) {
    fbb_.AddElement<uint8_t>(AccountInfo::VT_STATUS, static_cast<uint8_t>(status), 0);
  }
  void add_open_date(flatbuffers::Offset<flatbuffers::String> open_date) {
    fbb_.AddOffset(AccountInfo::VT_OPEN_DATE, open_date);
  }
  void add_extra_buying_power(flatbuffers::Offset<flatbuffers::String> extra_buying_power) {
    fbb_.AddOffset(AccountInfo::VT_EXTRA_BUYING_POWER, extra_buying_power);
  }
  void add_bankids(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Bank>>> bankids) {
    fbb_.AddOffset(AccountInfo::VT_BANKIDS, bankids);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(AccountInfo::VT_EXTRAS, extras);
  }
  void add_credit_value(flatbuffers::Offset<flatbuffers::String> credit_value) {
    fbb_.AddOffset(AccountInfo::VT_CREDIT_VALUE, credit_value);
  }
  void add_margin_scale_code(flatbuffers::Offset<flatbuffers::String> margin_scale_code) {
    fbb_.AddOffset(AccountInfo::VT_MARGIN_SCALE_CODE, margin_scale_code);
  }
  explicit AccountInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AccountInfoBuilder &operator=(const AccountInfoBuilder &);
  flatbuffers::Offset<AccountInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AccountInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<AccountInfo> CreateAccountInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> markets = 0,
    flatbuffers::Offset<flatbuffers::String> eng_name = 0,
    flatbuffers::Offset<flatbuffers::String> cht_name = 0,
    flatbuffers::Offset<flatbuffers::String> chs_name = 0,
    flatbuffers::Offset<flatbuffers::String> fax = 0,
    flatbuffers::Offset<flatbuffers::String> tel = 0,
    flatbuffers::Offset<flatbuffers::String> address = 0,
    Status status = Status_NONE,
    flatbuffers::Offset<flatbuffers::String> open_date = 0,
    flatbuffers::Offset<flatbuffers::String> extra_buying_power = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Bank>>> bankids = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0,
    flatbuffers::Offset<flatbuffers::String> credit_value = 0,
    flatbuffers::Offset<flatbuffers::String> margin_scale_code = 0) {
  AccountInfoBuilder builder_(_fbb);
  builder_.add_margin_scale_code(margin_scale_code);
  builder_.add_credit_value(credit_value);
  builder_.add_extras(extras);
  builder_.add_bankids(bankids);
  builder_.add_extra_buying_power(extra_buying_power);
  builder_.add_open_date(open_date);
  builder_.add_address(address);
  builder_.add_tel(tel);
  builder_.add_fax(fax);
  builder_.add_chs_name(chs_name);
  builder_.add_cht_name(cht_name);
  builder_.add_eng_name(eng_name);
  builder_.add_markets(markets);
  builder_.add_acc(acc);
  builder_.add_status(status);
  return builder_.Finish();
}

inline flatbuffers::Offset<AccountInfo> CreateAccountInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    const std::vector<uint8_t> *markets = nullptr,
    const char *eng_name = nullptr,
    const char *cht_name = nullptr,
    const char *chs_name = nullptr,
    const char *fax = nullptr,
    const char *tel = nullptr,
    const char *address = nullptr,
    Status status = Status_NONE,
    const char *open_date = nullptr,
    const char *extra_buying_power = nullptr,
    const std::vector<flatbuffers::Offset<Bank>> *bankids = nullptr,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr,
    const char *credit_value = nullptr,
    const char *margin_scale_code = nullptr) {
  return mm::CreateAccountInfo(
      _fbb,
      acc,
      markets ? _fbb.CreateVector<uint8_t>(*markets) : 0,
      eng_name ? _fbb.CreateString(eng_name) : 0,
      cht_name ? _fbb.CreateString(cht_name) : 0,
      chs_name ? _fbb.CreateString(chs_name) : 0,
      fax ? _fbb.CreateString(fax) : 0,
      tel ? _fbb.CreateString(tel) : 0,
      address ? _fbb.CreateString(address) : 0,
      status,
      open_date ? _fbb.CreateString(open_date) : 0,
      extra_buying_power ? _fbb.CreateString(extra_buying_power) : 0,
      bankids ? _fbb.CreateVector<flatbuffers::Offset<Bank>>(*bankids) : 0,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0,
      credit_value ? _fbb.CreateString(credit_value) : 0,
      margin_scale_code ? _fbb.CreateString(margin_scale_code) : 0);
}

struct UserInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RES = 4,
    VT_ITEMS = 6
  };
  const Result *res() const {
    return GetPointer<const Result *>(VT_RES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AccountInfo>> *items() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AccountInfo>> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RES) &&
           verifier.VerifyTable(res()) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.Verify(items()) &&
           verifier.VerifyVectorOfTables(items()) &&
           verifier.EndTable();
  }
};

struct UserInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_res(flatbuffers::Offset<Result> res) {
    fbb_.AddOffset(UserInfo::VT_RES, res);
  }
  void add_items(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AccountInfo>>> items) {
    fbb_.AddOffset(UserInfo::VT_ITEMS, items);
  }
  explicit UserInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UserInfoBuilder &operator=(const UserInfoBuilder &);
  flatbuffers::Offset<UserInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UserInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<UserInfo> CreateUserInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Result> res = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AccountInfo>>> items = 0) {
  UserInfoBuilder builder_(_fbb);
  builder_.add_items(items);
  builder_.add_res(res);
  return builder_.Finish();
}

inline flatbuffers::Offset<UserInfo> CreateUserInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Result> res = 0,
    const std::vector<flatbuffers::Offset<AccountInfo>> *items = nullptr) {
  return mm::CreateUserInfo(
      _fbb,
      res,
      items ? _fbb.CreateVector<flatbuffers::Offset<AccountInfo>>(*items) : 0);
}

struct Fund FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACC = 4,
    VT_CCY = 6,
    VT_BALANCE = 8,
    VT_FROZEN = 10,
    VT_USABLE = 12,
    VT_WITHDRAWN = 14,
    VT_UNCLEARED = 16,
    VT_CREDIT_VALUE = 18,
    VT_MARGIN_VALUE = 20,
    VT_BOD_BALANCE = 22,
    VT_TODAY_CASHIO = 24,
    VT_UNCLEAR = 26,
    VT_BASIC_MARGIN = 28,
    VT_EXTRAS = 30,
    VT_MIN_MARGIN = 32
  };
  const Account *acc() const {
    return GetPointer<const Account *>(VT_ACC);
  }
  Currency ccy() const {
    return static_cast<Currency>(GetField<uint8_t>(VT_CCY, 0));
  }
  const flatbuffers::String *balance() const {
    return GetPointer<const flatbuffers::String *>(VT_BALANCE);
  }
  const flatbuffers::String *frozen() const {
    return GetPointer<const flatbuffers::String *>(VT_FROZEN);
  }
  const flatbuffers::String *usable() const {
    return GetPointer<const flatbuffers::String *>(VT_USABLE);
  }
  const flatbuffers::String *withdrawn() const {
    return GetPointer<const flatbuffers::String *>(VT_WITHDRAWN);
  }
  const flatbuffers::String *uncleared() const {
    return GetPointer<const flatbuffers::String *>(VT_UNCLEARED);
  }
  const flatbuffers::String *credit_value() const {
    return GetPointer<const flatbuffers::String *>(VT_CREDIT_VALUE);
  }
  const flatbuffers::String *margin_value() const {
    return GetPointer<const flatbuffers::String *>(VT_MARGIN_VALUE);
  }
  const flatbuffers::String *bod_balance() const {
    return GetPointer<const flatbuffers::String *>(VT_BOD_BALANCE);
  }
  const flatbuffers::String *today_cashio() const {
    return GetPointer<const flatbuffers::String *>(VT_TODAY_CASHIO);
  }
  const flatbuffers::String *unclear() const {
    return GetPointer<const flatbuffers::String *>(VT_UNCLEAR);
  }
  const flatbuffers::String *basic_margin() const {
    return GetPointer<const flatbuffers::String *>(VT_BASIC_MARGIN);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  const flatbuffers::String *min_margin() const {
    return GetPointer<const flatbuffers::String *>(VT_MIN_MARGIN);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACC) &&
           verifier.VerifyTable(acc()) &&
           VerifyField<uint8_t>(verifier, VT_CCY) &&
           VerifyOffset(verifier, VT_BALANCE) &&
           verifier.Verify(balance()) &&
           VerifyOffset(verifier, VT_FROZEN) &&
           verifier.Verify(frozen()) &&
           VerifyOffset(verifier, VT_USABLE) &&
           verifier.Verify(usable()) &&
           VerifyOffset(verifier, VT_WITHDRAWN) &&
           verifier.Verify(withdrawn()) &&
           VerifyOffset(verifier, VT_UNCLEARED) &&
           verifier.Verify(uncleared()) &&
           VerifyOffset(verifier, VT_CREDIT_VALUE) &&
           verifier.Verify(credit_value()) &&
           VerifyOffset(verifier, VT_MARGIN_VALUE) &&
           verifier.Verify(margin_value()) &&
           VerifyOffset(verifier, VT_BOD_BALANCE) &&
           verifier.Verify(bod_balance()) &&
           VerifyOffset(verifier, VT_TODAY_CASHIO) &&
           verifier.Verify(today_cashio()) &&
           VerifyOffset(verifier, VT_UNCLEAR) &&
           verifier.Verify(unclear()) &&
           VerifyOffset(verifier, VT_BASIC_MARGIN) &&
           verifier.Verify(basic_margin()) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           VerifyOffset(verifier, VT_MIN_MARGIN) &&
           verifier.Verify(min_margin()) &&
           verifier.EndTable();
  }
};

struct FundBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acc(flatbuffers::Offset<Account> acc) {
    fbb_.AddOffset(Fund::VT_ACC, acc);
  }
  void add_ccy(Currency ccy) {
    fbb_.AddElement<uint8_t>(Fund::VT_CCY, static_cast<uint8_t>(ccy), 0);
  }
  void add_balance(flatbuffers::Offset<flatbuffers::String> balance) {
    fbb_.AddOffset(Fund::VT_BALANCE, balance);
  }
  void add_frozen(flatbuffers::Offset<flatbuffers::String> frozen) {
    fbb_.AddOffset(Fund::VT_FROZEN, frozen);
  }
  void add_usable(flatbuffers::Offset<flatbuffers::String> usable) {
    fbb_.AddOffset(Fund::VT_USABLE, usable);
  }
  void add_withdrawn(flatbuffers::Offset<flatbuffers::String> withdrawn) {
    fbb_.AddOffset(Fund::VT_WITHDRAWN, withdrawn);
  }
  void add_uncleared(flatbuffers::Offset<flatbuffers::String> uncleared) {
    fbb_.AddOffset(Fund::VT_UNCLEARED, uncleared);
  }
  void add_credit_value(flatbuffers::Offset<flatbuffers::String> credit_value) {
    fbb_.AddOffset(Fund::VT_CREDIT_VALUE, credit_value);
  }
  void add_margin_value(flatbuffers::Offset<flatbuffers::String> margin_value) {
    fbb_.AddOffset(Fund::VT_MARGIN_VALUE, margin_value);
  }
  void add_bod_balance(flatbuffers::Offset<flatbuffers::String> bod_balance) {
    fbb_.AddOffset(Fund::VT_BOD_BALANCE, bod_balance);
  }
  void add_today_cashio(flatbuffers::Offset<flatbuffers::String> today_cashio) {
    fbb_.AddOffset(Fund::VT_TODAY_CASHIO, today_cashio);
  }
  void add_unclear(flatbuffers::Offset<flatbuffers::String> unclear) {
    fbb_.AddOffset(Fund::VT_UNCLEAR, unclear);
  }
  void add_basic_margin(flatbuffers::Offset<flatbuffers::String> basic_margin) {
    fbb_.AddOffset(Fund::VT_BASIC_MARGIN, basic_margin);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(Fund::VT_EXTRAS, extras);
  }
  void add_min_margin(flatbuffers::Offset<flatbuffers::String> min_margin) {
    fbb_.AddOffset(Fund::VT_MIN_MARGIN, min_margin);
  }
  explicit FundBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FundBuilder &operator=(const FundBuilder &);
  flatbuffers::Offset<Fund> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Fund>(end);
    return o;
  }
};

inline flatbuffers::Offset<Fund> CreateFund(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    Currency ccy = Currency_NONE,
    flatbuffers::Offset<flatbuffers::String> balance = 0,
    flatbuffers::Offset<flatbuffers::String> frozen = 0,
    flatbuffers::Offset<flatbuffers::String> usable = 0,
    flatbuffers::Offset<flatbuffers::String> withdrawn = 0,
    flatbuffers::Offset<flatbuffers::String> uncleared = 0,
    flatbuffers::Offset<flatbuffers::String> credit_value = 0,
    flatbuffers::Offset<flatbuffers::String> margin_value = 0,
    flatbuffers::Offset<flatbuffers::String> bod_balance = 0,
    flatbuffers::Offset<flatbuffers::String> today_cashio = 0,
    flatbuffers::Offset<flatbuffers::String> unclear = 0,
    flatbuffers::Offset<flatbuffers::String> basic_margin = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0,
    flatbuffers::Offset<flatbuffers::String> min_margin = 0) {
  FundBuilder builder_(_fbb);
  builder_.add_min_margin(min_margin);
  builder_.add_extras(extras);
  builder_.add_basic_margin(basic_margin);
  builder_.add_unclear(unclear);
  builder_.add_today_cashio(today_cashio);
  builder_.add_bod_balance(bod_balance);
  builder_.add_margin_value(margin_value);
  builder_.add_credit_value(credit_value);
  builder_.add_uncleared(uncleared);
  builder_.add_withdrawn(withdrawn);
  builder_.add_usable(usable);
  builder_.add_frozen(frozen);
  builder_.add_balance(balance);
  builder_.add_acc(acc);
  builder_.add_ccy(ccy);
  return builder_.Finish();
}

inline flatbuffers::Offset<Fund> CreateFundDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    Currency ccy = Currency_NONE,
    const char *balance = nullptr,
    const char *frozen = nullptr,
    const char *usable = nullptr,
    const char *withdrawn = nullptr,
    const char *uncleared = nullptr,
    const char *credit_value = nullptr,
    const char *margin_value = nullptr,
    const char *bod_balance = nullptr,
    const char *today_cashio = nullptr,
    const char *unclear = nullptr,
    const char *basic_margin = nullptr,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr,
    const char *min_margin = nullptr) {
  return mm::CreateFund(
      _fbb,
      acc,
      ccy,
      balance ? _fbb.CreateString(balance) : 0,
      frozen ? _fbb.CreateString(frozen) : 0,
      usable ? _fbb.CreateString(usable) : 0,
      withdrawn ? _fbb.CreateString(withdrawn) : 0,
      uncleared ? _fbb.CreateString(uncleared) : 0,
      credit_value ? _fbb.CreateString(credit_value) : 0,
      margin_value ? _fbb.CreateString(margin_value) : 0,
      bod_balance ? _fbb.CreateString(bod_balance) : 0,
      today_cashio ? _fbb.CreateString(today_cashio) : 0,
      unclear ? _fbb.CreateString(unclear) : 0,
      basic_margin ? _fbb.CreateString(basic_margin) : 0,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0,
      min_margin ? _fbb.CreateString(min_margin) : 0);
}

struct Hold FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACC = 4,
    VT_MARKET = 6,
    VT_SYMBOL = 8,
    VT_QTY = 10,
    VT_MARGIN_RATO = 12,
    VT_UNCLEARED = 14,
    VT_TODAY_BUY_QTY = 16,
    VT_TODAY_SELL_QTY = 18,
    VT_TODAY_BUY_AMOUNT = 20,
    VT_TODAY_SELL_AMOUNT = 22,
    VT_AVG_PRICE = 24,
    VT_COST_PRICE = 26,
    VT_BOD_QTY = 28,
    VT_BOD_COST_PRICE = 30,
    VT_BOD_AVG_PRICE = 32,
    VT_LONG_POSITION = 34,
    VT_LONG_AVG_PRICE = 36,
    VT_SHORT_POSITION = 38,
    VT_SHORT_AVG_PRICE = 40,
    VT_EXTRAS = 42,
    VT_HOLD_AVG_PRICE = 44
  };
  const Account *acc() const {
    return GetPointer<const Account *>(VT_ACC);
  }
  Market market() const {
    return static_cast<Market>(GetField<uint8_t>(VT_MARKET, 0));
  }
  const flatbuffers::String *symbol() const {
    return GetPointer<const flatbuffers::String *>(VT_SYMBOL);
  }
  const flatbuffers::String *qty() const {
    return GetPointer<const flatbuffers::String *>(VT_QTY);
  }
  const flatbuffers::String *margin_rato() const {
    return GetPointer<const flatbuffers::String *>(VT_MARGIN_RATO);
  }
  const flatbuffers::String *uncleared() const {
    return GetPointer<const flatbuffers::String *>(VT_UNCLEARED);
  }
  const flatbuffers::String *today_buy_qty() const {
    return GetPointer<const flatbuffers::String *>(VT_TODAY_BUY_QTY);
  }
  const flatbuffers::String *today_sell_qty() const {
    return GetPointer<const flatbuffers::String *>(VT_TODAY_SELL_QTY);
  }
  const flatbuffers::String *today_buy_amount() const {
    return GetPointer<const flatbuffers::String *>(VT_TODAY_BUY_AMOUNT);
  }
  const flatbuffers::String *today_sell_amount() const {
    return GetPointer<const flatbuffers::String *>(VT_TODAY_SELL_AMOUNT);
  }
  const flatbuffers::String *avg_price() const {
    return GetPointer<const flatbuffers::String *>(VT_AVG_PRICE);
  }
  const flatbuffers::String *cost_price() const {
    return GetPointer<const flatbuffers::String *>(VT_COST_PRICE);
  }
  const flatbuffers::String *bod_qty() const {
    return GetPointer<const flatbuffers::String *>(VT_BOD_QTY);
  }
  const flatbuffers::String *bod_cost_price() const {
    return GetPointer<const flatbuffers::String *>(VT_BOD_COST_PRICE);
  }
  const flatbuffers::String *bod_avg_price() const {
    return GetPointer<const flatbuffers::String *>(VT_BOD_AVG_PRICE);
  }
  const flatbuffers::String *long_position() const {
    return GetPointer<const flatbuffers::String *>(VT_LONG_POSITION);
  }
  const flatbuffers::String *long_avg_price() const {
    return GetPointer<const flatbuffers::String *>(VT_LONG_AVG_PRICE);
  }
  const flatbuffers::String *short_position() const {
    return GetPointer<const flatbuffers::String *>(VT_SHORT_POSITION);
  }
  const flatbuffers::String *short_avg_price() const {
    return GetPointer<const flatbuffers::String *>(VT_SHORT_AVG_PRICE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  const flatbuffers::String *hold_avg_price() const {
    return GetPointer<const flatbuffers::String *>(VT_HOLD_AVG_PRICE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACC) &&
           verifier.VerifyTable(acc()) &&
           VerifyField<uint8_t>(verifier, VT_MARKET) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.Verify(symbol()) &&
           VerifyOffset(verifier, VT_QTY) &&
           verifier.Verify(qty()) &&
           VerifyOffset(verifier, VT_MARGIN_RATO) &&
           verifier.Verify(margin_rato()) &&
           VerifyOffset(verifier, VT_UNCLEARED) &&
           verifier.Verify(uncleared()) &&
           VerifyOffset(verifier, VT_TODAY_BUY_QTY) &&
           verifier.Verify(today_buy_qty()) &&
           VerifyOffset(verifier, VT_TODAY_SELL_QTY) &&
           verifier.Verify(today_sell_qty()) &&
           VerifyOffset(verifier, VT_TODAY_BUY_AMOUNT) &&
           verifier.Verify(today_buy_amount()) &&
           VerifyOffset(verifier, VT_TODAY_SELL_AMOUNT) &&
           verifier.Verify(today_sell_amount()) &&
           VerifyOffset(verifier, VT_AVG_PRICE) &&
           verifier.Verify(avg_price()) &&
           VerifyOffset(verifier, VT_COST_PRICE) &&
           verifier.Verify(cost_price()) &&
           VerifyOffset(verifier, VT_BOD_QTY) &&
           verifier.Verify(bod_qty()) &&
           VerifyOffset(verifier, VT_BOD_COST_PRICE) &&
           verifier.Verify(bod_cost_price()) &&
           VerifyOffset(verifier, VT_BOD_AVG_PRICE) &&
           verifier.Verify(bod_avg_price()) &&
           VerifyOffset(verifier, VT_LONG_POSITION) &&
           verifier.Verify(long_position()) &&
           VerifyOffset(verifier, VT_LONG_AVG_PRICE) &&
           verifier.Verify(long_avg_price()) &&
           VerifyOffset(verifier, VT_SHORT_POSITION) &&
           verifier.Verify(short_position()) &&
           VerifyOffset(verifier, VT_SHORT_AVG_PRICE) &&
           verifier.Verify(short_avg_price()) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           VerifyOffset(verifier, VT_HOLD_AVG_PRICE) &&
           verifier.Verify(hold_avg_price()) &&
           verifier.EndTable();
  }
};

struct HoldBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acc(flatbuffers::Offset<Account> acc) {
    fbb_.AddOffset(Hold::VT_ACC, acc);
  }
  void add_market(Market market) {
    fbb_.AddElement<uint8_t>(Hold::VT_MARKET, static_cast<uint8_t>(market), 0);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) {
    fbb_.AddOffset(Hold::VT_SYMBOL, symbol);
  }
  void add_qty(flatbuffers::Offset<flatbuffers::String> qty) {
    fbb_.AddOffset(Hold::VT_QTY, qty);
  }
  void add_margin_rato(flatbuffers::Offset<flatbuffers::String> margin_rato) {
    fbb_.AddOffset(Hold::VT_MARGIN_RATO, margin_rato);
  }
  void add_uncleared(flatbuffers::Offset<flatbuffers::String> uncleared) {
    fbb_.AddOffset(Hold::VT_UNCLEARED, uncleared);
  }
  void add_today_buy_qty(flatbuffers::Offset<flatbuffers::String> today_buy_qty) {
    fbb_.AddOffset(Hold::VT_TODAY_BUY_QTY, today_buy_qty);
  }
  void add_today_sell_qty(flatbuffers::Offset<flatbuffers::String> today_sell_qty) {
    fbb_.AddOffset(Hold::VT_TODAY_SELL_QTY, today_sell_qty);
  }
  void add_today_buy_amount(flatbuffers::Offset<flatbuffers::String> today_buy_amount) {
    fbb_.AddOffset(Hold::VT_TODAY_BUY_AMOUNT, today_buy_amount);
  }
  void add_today_sell_amount(flatbuffers::Offset<flatbuffers::String> today_sell_amount) {
    fbb_.AddOffset(Hold::VT_TODAY_SELL_AMOUNT, today_sell_amount);
  }
  void add_avg_price(flatbuffers::Offset<flatbuffers::String> avg_price) {
    fbb_.AddOffset(Hold::VT_AVG_PRICE, avg_price);
  }
  void add_cost_price(flatbuffers::Offset<flatbuffers::String> cost_price) {
    fbb_.AddOffset(Hold::VT_COST_PRICE, cost_price);
  }
  void add_bod_qty(flatbuffers::Offset<flatbuffers::String> bod_qty) {
    fbb_.AddOffset(Hold::VT_BOD_QTY, bod_qty);
  }
  void add_bod_cost_price(flatbuffers::Offset<flatbuffers::String> bod_cost_price) {
    fbb_.AddOffset(Hold::VT_BOD_COST_PRICE, bod_cost_price);
  }
  void add_bod_avg_price(flatbuffers::Offset<flatbuffers::String> bod_avg_price) {
    fbb_.AddOffset(Hold::VT_BOD_AVG_PRICE, bod_avg_price);
  }
  void add_long_position(flatbuffers::Offset<flatbuffers::String> long_position) {
    fbb_.AddOffset(Hold::VT_LONG_POSITION, long_position);
  }
  void add_long_avg_price(flatbuffers::Offset<flatbuffers::String> long_avg_price) {
    fbb_.AddOffset(Hold::VT_LONG_AVG_PRICE, long_avg_price);
  }
  void add_short_position(flatbuffers::Offset<flatbuffers::String> short_position) {
    fbb_.AddOffset(Hold::VT_SHORT_POSITION, short_position);
  }
  void add_short_avg_price(flatbuffers::Offset<flatbuffers::String> short_avg_price) {
    fbb_.AddOffset(Hold::VT_SHORT_AVG_PRICE, short_avg_price);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(Hold::VT_EXTRAS, extras);
  }
  void add_hold_avg_price(flatbuffers::Offset<flatbuffers::String> hold_avg_price) {
    fbb_.AddOffset(Hold::VT_HOLD_AVG_PRICE, hold_avg_price);
  }
  explicit HoldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HoldBuilder &operator=(const HoldBuilder &);
  flatbuffers::Offset<Hold> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Hold>(end);
    return o;
  }
};

inline flatbuffers::Offset<Hold> CreateHold(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    Market market = Market_NONE,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    flatbuffers::Offset<flatbuffers::String> qty = 0,
    flatbuffers::Offset<flatbuffers::String> margin_rato = 0,
    flatbuffers::Offset<flatbuffers::String> uncleared = 0,
    flatbuffers::Offset<flatbuffers::String> today_buy_qty = 0,
    flatbuffers::Offset<flatbuffers::String> today_sell_qty = 0,
    flatbuffers::Offset<flatbuffers::String> today_buy_amount = 0,
    flatbuffers::Offset<flatbuffers::String> today_sell_amount = 0,
    flatbuffers::Offset<flatbuffers::String> avg_price = 0,
    flatbuffers::Offset<flatbuffers::String> cost_price = 0,
    flatbuffers::Offset<flatbuffers::String> bod_qty = 0,
    flatbuffers::Offset<flatbuffers::String> bod_cost_price = 0,
    flatbuffers::Offset<flatbuffers::String> bod_avg_price = 0,
    flatbuffers::Offset<flatbuffers::String> long_position = 0,
    flatbuffers::Offset<flatbuffers::String> long_avg_price = 0,
    flatbuffers::Offset<flatbuffers::String> short_position = 0,
    flatbuffers::Offset<flatbuffers::String> short_avg_price = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0,
    flatbuffers::Offset<flatbuffers::String> hold_avg_price = 0) {
  HoldBuilder builder_(_fbb);
  builder_.add_hold_avg_price(hold_avg_price);
  builder_.add_extras(extras);
  builder_.add_short_avg_price(short_avg_price);
  builder_.add_short_position(short_position);
  builder_.add_long_avg_price(long_avg_price);
  builder_.add_long_position(long_position);
  builder_.add_bod_avg_price(bod_avg_price);
  builder_.add_bod_cost_price(bod_cost_price);
  builder_.add_bod_qty(bod_qty);
  builder_.add_cost_price(cost_price);
  builder_.add_avg_price(avg_price);
  builder_.add_today_sell_amount(today_sell_amount);
  builder_.add_today_buy_amount(today_buy_amount);
  builder_.add_today_sell_qty(today_sell_qty);
  builder_.add_today_buy_qty(today_buy_qty);
  builder_.add_uncleared(uncleared);
  builder_.add_margin_rato(margin_rato);
  builder_.add_qty(qty);
  builder_.add_symbol(symbol);
  builder_.add_acc(acc);
  builder_.add_market(market);
  return builder_.Finish();
}

inline flatbuffers::Offset<Hold> CreateHoldDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    Market market = Market_NONE,
    const char *symbol = nullptr,
    const char *qty = nullptr,
    const char *margin_rato = nullptr,
    const char *uncleared = nullptr,
    const char *today_buy_qty = nullptr,
    const char *today_sell_qty = nullptr,
    const char *today_buy_amount = nullptr,
    const char *today_sell_amount = nullptr,
    const char *avg_price = nullptr,
    const char *cost_price = nullptr,
    const char *bod_qty = nullptr,
    const char *bod_cost_price = nullptr,
    const char *bod_avg_price = nullptr,
    const char *long_position = nullptr,
    const char *long_avg_price = nullptr,
    const char *short_position = nullptr,
    const char *short_avg_price = nullptr,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr,
    const char *hold_avg_price = nullptr) {
  return mm::CreateHold(
      _fbb,
      acc,
      market,
      symbol ? _fbb.CreateString(symbol) : 0,
      qty ? _fbb.CreateString(qty) : 0,
      margin_rato ? _fbb.CreateString(margin_rato) : 0,
      uncleared ? _fbb.CreateString(uncleared) : 0,
      today_buy_qty ? _fbb.CreateString(today_buy_qty) : 0,
      today_sell_qty ? _fbb.CreateString(today_sell_qty) : 0,
      today_buy_amount ? _fbb.CreateString(today_buy_amount) : 0,
      today_sell_amount ? _fbb.CreateString(today_sell_amount) : 0,
      avg_price ? _fbb.CreateString(avg_price) : 0,
      cost_price ? _fbb.CreateString(cost_price) : 0,
      bod_qty ? _fbb.CreateString(bod_qty) : 0,
      bod_cost_price ? _fbb.CreateString(bod_cost_price) : 0,
      bod_avg_price ? _fbb.CreateString(bod_avg_price) : 0,
      long_position ? _fbb.CreateString(long_position) : 0,
      long_avg_price ? _fbb.CreateString(long_avg_price) : 0,
      short_position ? _fbb.CreateString(short_position) : 0,
      short_avg_price ? _fbb.CreateString(short_avg_price) : 0,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0,
      hold_avg_price ? _fbb.CreateString(hold_avg_price) : 0);
}

struct PositionNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACC = 4,
    VT_TIME = 6,
    VT_SERIALNO = 8,
    VT_MARKET = 10,
    VT_SYMBOL = 12,
    VT_QTY = 14,
    VT_EXTRAS = 16
  };
  const Account *acc() const {
    return GetPointer<const Account *>(VT_ACC);
  }
  const flatbuffers::String *time() const {
    return GetPointer<const flatbuffers::String *>(VT_TIME);
  }
  const flatbuffers::String *serialno() const {
    return GetPointer<const flatbuffers::String *>(VT_SERIALNO);
  }
  Market market() const {
    return static_cast<Market>(GetField<uint8_t>(VT_MARKET, 0));
  }
  const flatbuffers::String *symbol() const {
    return GetPointer<const flatbuffers::String *>(VT_SYMBOL);
  }
  const flatbuffers::String *qty() const {
    return GetPointer<const flatbuffers::String *>(VT_QTY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACC) &&
           verifier.VerifyTable(acc()) &&
           VerifyOffset(verifier, VT_TIME) &&
           verifier.Verify(time()) &&
           VerifyOffset(verifier, VT_SERIALNO) &&
           verifier.Verify(serialno()) &&
           VerifyField<uint8_t>(verifier, VT_MARKET) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.Verify(symbol()) &&
           VerifyOffset(verifier, VT_QTY) &&
           verifier.Verify(qty()) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           verifier.EndTable();
  }
};

struct PositionNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acc(flatbuffers::Offset<Account> acc) {
    fbb_.AddOffset(PositionNotify::VT_ACC, acc);
  }
  void add_time(flatbuffers::Offset<flatbuffers::String> time) {
    fbb_.AddOffset(PositionNotify::VT_TIME, time);
  }
  void add_serialno(flatbuffers::Offset<flatbuffers::String> serialno) {
    fbb_.AddOffset(PositionNotify::VT_SERIALNO, serialno);
  }
  void add_market(Market market) {
    fbb_.AddElement<uint8_t>(PositionNotify::VT_MARKET, static_cast<uint8_t>(market), 0);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) {
    fbb_.AddOffset(PositionNotify::VT_SYMBOL, symbol);
  }
  void add_qty(flatbuffers::Offset<flatbuffers::String> qty) {
    fbb_.AddOffset(PositionNotify::VT_QTY, qty);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(PositionNotify::VT_EXTRAS, extras);
  }
  explicit PositionNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PositionNotifyBuilder &operator=(const PositionNotifyBuilder &);
  flatbuffers::Offset<PositionNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PositionNotify>(end);
    return o;
  }
};

inline flatbuffers::Offset<PositionNotify> CreatePositionNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    flatbuffers::Offset<flatbuffers::String> time = 0,
    flatbuffers::Offset<flatbuffers::String> serialno = 0,
    Market market = Market_NONE,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    flatbuffers::Offset<flatbuffers::String> qty = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0) {
  PositionNotifyBuilder builder_(_fbb);
  builder_.add_extras(extras);
  builder_.add_qty(qty);
  builder_.add_symbol(symbol);
  builder_.add_serialno(serialno);
  builder_.add_time(time);
  builder_.add_acc(acc);
  builder_.add_market(market);
  return builder_.Finish();
}

inline flatbuffers::Offset<PositionNotify> CreatePositionNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    const char *time = nullptr,
    const char *serialno = nullptr,
    Market market = Market_NONE,
    const char *symbol = nullptr,
    const char *qty = nullptr,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr) {
  return mm::CreatePositionNotify(
      _fbb,
      acc,
      time ? _fbb.CreateString(time) : 0,
      serialno ? _fbb.CreateString(serialno) : 0,
      market,
      symbol ? _fbb.CreateString(symbol) : 0,
      qty ? _fbb.CreateString(qty) : 0,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0);
}

struct Notify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACC = 4,
    VT_MSG = 6,
    VT_OPERATION = 8,
    VT_EXTRAS = 10
  };
  const Account *acc() const {
    return GetPointer<const Account *>(VT_ACC);
  }
  const flatbuffers::String *msg() const {
    return GetPointer<const flatbuffers::String *>(VT_MSG);
  }
  Action operation() const {
    return static_cast<Action>(GetField<uint8_t>(VT_OPERATION, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACC) &&
           verifier.VerifyTable(acc()) &&
           VerifyOffset(verifier, VT_MSG) &&
           verifier.Verify(msg()) &&
           VerifyField<uint8_t>(verifier, VT_OPERATION) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           verifier.EndTable();
  }
};

struct NotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acc(flatbuffers::Offset<Account> acc) {
    fbb_.AddOffset(Notify::VT_ACC, acc);
  }
  void add_msg(flatbuffers::Offset<flatbuffers::String> msg) {
    fbb_.AddOffset(Notify::VT_MSG, msg);
  }
  void add_operation(Action operation) {
    fbb_.AddElement<uint8_t>(Notify::VT_OPERATION, static_cast<uint8_t>(operation), 0);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(Notify::VT_EXTRAS, extras);
  }
  explicit NotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NotifyBuilder &operator=(const NotifyBuilder &);
  flatbuffers::Offset<Notify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Notify>(end);
    return o;
  }
};

inline flatbuffers::Offset<Notify> CreateNotify(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    flatbuffers::Offset<flatbuffers::String> msg = 0,
    Action operation = Action_NONE,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0) {
  NotifyBuilder builder_(_fbb);
  builder_.add_extras(extras);
  builder_.add_msg(msg);
  builder_.add_acc(acc);
  builder_.add_operation(operation);
  return builder_.Finish();
}

inline flatbuffers::Offset<Notify> CreateNotifyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    const char *msg = nullptr,
    Action operation = Action_NONE,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr) {
  return mm::CreateNotify(
      _fbb,
      acc,
      msg ? _fbb.CreateString(msg) : 0,
      operation,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0);
}

struct Margin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACC = 4,
    VT_CCY = 6,
    VT_BASIC_MARGIN = 8,
    VT_MIN_MAGIN = 10,
    VT_EXTRAS = 12
  };
  const Account *acc() const {
    return GetPointer<const Account *>(VT_ACC);
  }
  Currency ccy() const {
    return static_cast<Currency>(GetField<uint8_t>(VT_CCY, 0));
  }
  const flatbuffers::String *basic_margin() const {
    return GetPointer<const flatbuffers::String *>(VT_BASIC_MARGIN);
  }
  const flatbuffers::String *min_magin() const {
    return GetPointer<const flatbuffers::String *>(VT_MIN_MAGIN);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACC) &&
           verifier.VerifyTable(acc()) &&
           VerifyField<uint8_t>(verifier, VT_CCY) &&
           VerifyOffset(verifier, VT_BASIC_MARGIN) &&
           verifier.Verify(basic_margin()) &&
           VerifyOffset(verifier, VT_MIN_MAGIN) &&
           verifier.Verify(min_magin()) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           verifier.EndTable();
  }
};

struct MarginBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acc(flatbuffers::Offset<Account> acc) {
    fbb_.AddOffset(Margin::VT_ACC, acc);
  }
  void add_ccy(Currency ccy) {
    fbb_.AddElement<uint8_t>(Margin::VT_CCY, static_cast<uint8_t>(ccy), 0);
  }
  void add_basic_margin(flatbuffers::Offset<flatbuffers::String> basic_margin) {
    fbb_.AddOffset(Margin::VT_BASIC_MARGIN, basic_margin);
  }
  void add_min_magin(flatbuffers::Offset<flatbuffers::String> min_magin) {
    fbb_.AddOffset(Margin::VT_MIN_MAGIN, min_magin);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(Margin::VT_EXTRAS, extras);
  }
  explicit MarginBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MarginBuilder &operator=(const MarginBuilder &);
  flatbuffers::Offset<Margin> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Margin>(end);
    return o;
  }
};

inline flatbuffers::Offset<Margin> CreateMargin(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    Currency ccy = Currency_NONE,
    flatbuffers::Offset<flatbuffers::String> basic_margin = 0,
    flatbuffers::Offset<flatbuffers::String> min_magin = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0) {
  MarginBuilder builder_(_fbb);
  builder_.add_extras(extras);
  builder_.add_min_magin(min_magin);
  builder_.add_basic_margin(basic_margin);
  builder_.add_acc(acc);
  builder_.add_ccy(ccy);
  return builder_.Finish();
}

inline flatbuffers::Offset<Margin> CreateMarginDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    Currency ccy = Currency_NONE,
    const char *basic_margin = nullptr,
    const char *min_magin = nullptr,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr) {
  return mm::CreateMargin(
      _fbb,
      acc,
      ccy,
      basic_margin ? _fbb.CreateString(basic_margin) : 0,
      min_magin ? _fbb.CreateString(min_magin) : 0,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0);
}

struct Recovery FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACC = 4,
    VT_MSGID_BEGIN = 6,
    VT_MSGID_END = 8,
    VT_EXTRAS = 10
  };
  const Account *acc() const {
    return GetPointer<const Account *>(VT_ACC);
  }
  uint32_t msgid_begin() const {
    return GetField<uint32_t>(VT_MSGID_BEGIN, 0);
  }
  uint32_t msgid_end() const {
    return GetField<uint32_t>(VT_MSGID_END, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACC) &&
           verifier.VerifyTable(acc()) &&
           VerifyField<uint32_t>(verifier, VT_MSGID_BEGIN) &&
           VerifyField<uint32_t>(verifier, VT_MSGID_END) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           verifier.EndTable();
  }
};

struct RecoveryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acc(flatbuffers::Offset<Account> acc) {
    fbb_.AddOffset(Recovery::VT_ACC, acc);
  }
  void add_msgid_begin(uint32_t msgid_begin) {
    fbb_.AddElement<uint32_t>(Recovery::VT_MSGID_BEGIN, msgid_begin, 0);
  }
  void add_msgid_end(uint32_t msgid_end) {
    fbb_.AddElement<uint32_t>(Recovery::VT_MSGID_END, msgid_end, 0);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(Recovery::VT_EXTRAS, extras);
  }
  explicit RecoveryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RecoveryBuilder &operator=(const RecoveryBuilder &);
  flatbuffers::Offset<Recovery> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Recovery>(end);
    return o;
  }
};

inline flatbuffers::Offset<Recovery> CreateRecovery(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    uint32_t msgid_begin = 0,
    uint32_t msgid_end = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0) {
  RecoveryBuilder builder_(_fbb);
  builder_.add_extras(extras);
  builder_.add_msgid_end(msgid_end);
  builder_.add_msgid_begin(msgid_begin);
  builder_.add_acc(acc);
  return builder_.Finish();
}

inline flatbuffers::Offset<Recovery> CreateRecoveryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    uint32_t msgid_begin = 0,
    uint32_t msgid_end = 0,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr) {
  return mm::CreateRecovery(
      _fbb,
      acc,
      msgid_begin,
      msgid_end,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0);
}

struct VerifyCode_req FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACC = 4,
    VT_DEVICE_NAME = 6,
    VT_DEVICE_CODE = 8,
    VT_TERMINAL = 10,
    VT_IP = 12,
    VT_EXTRAS = 14
  };
  const Account *acc() const {
    return GetPointer<const Account *>(VT_ACC);
  }
  const flatbuffers::String *device_name() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICE_NAME);
  }
  const flatbuffers::String *device_code() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICE_CODE);
  }
  TerminalType terminal() const {
    return static_cast<TerminalType>(GetField<uint8_t>(VT_TERMINAL, 0));
  }
  const flatbuffers::String *ip() const {
    return GetPointer<const flatbuffers::String *>(VT_IP);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACC) &&
           verifier.VerifyTable(acc()) &&
           VerifyOffset(verifier, VT_DEVICE_NAME) &&
           verifier.Verify(device_name()) &&
           VerifyOffset(verifier, VT_DEVICE_CODE) &&
           verifier.Verify(device_code()) &&
           VerifyField<uint8_t>(verifier, VT_TERMINAL) &&
           VerifyOffset(verifier, VT_IP) &&
           verifier.Verify(ip()) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           verifier.EndTable();
  }
};

struct VerifyCode_reqBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acc(flatbuffers::Offset<Account> acc) {
    fbb_.AddOffset(VerifyCode_req::VT_ACC, acc);
  }
  void add_device_name(flatbuffers::Offset<flatbuffers::String> device_name) {
    fbb_.AddOffset(VerifyCode_req::VT_DEVICE_NAME, device_name);
  }
  void add_device_code(flatbuffers::Offset<flatbuffers::String> device_code) {
    fbb_.AddOffset(VerifyCode_req::VT_DEVICE_CODE, device_code);
  }
  void add_terminal(TerminalType terminal) {
    fbb_.AddElement<uint8_t>(VerifyCode_req::VT_TERMINAL, static_cast<uint8_t>(terminal), 0);
  }
  void add_ip(flatbuffers::Offset<flatbuffers::String> ip) {
    fbb_.AddOffset(VerifyCode_req::VT_IP, ip);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(VerifyCode_req::VT_EXTRAS, extras);
  }
  explicit VerifyCode_reqBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VerifyCode_reqBuilder &operator=(const VerifyCode_reqBuilder &);
  flatbuffers::Offset<VerifyCode_req> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VerifyCode_req>(end);
    return o;
  }
};

inline flatbuffers::Offset<VerifyCode_req> CreateVerifyCode_req(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    flatbuffers::Offset<flatbuffers::String> device_name = 0,
    flatbuffers::Offset<flatbuffers::String> device_code = 0,
    TerminalType terminal = TerminalType_NONE,
    flatbuffers::Offset<flatbuffers::String> ip = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0) {
  VerifyCode_reqBuilder builder_(_fbb);
  builder_.add_extras(extras);
  builder_.add_ip(ip);
  builder_.add_device_code(device_code);
  builder_.add_device_name(device_name);
  builder_.add_acc(acc);
  builder_.add_terminal(terminal);
  return builder_.Finish();
}

inline flatbuffers::Offset<VerifyCode_req> CreateVerifyCode_reqDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    const char *device_name = nullptr,
    const char *device_code = nullptr,
    TerminalType terminal = TerminalType_NONE,
    const char *ip = nullptr,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr) {
  return mm::CreateVerifyCode_req(
      _fbb,
      acc,
      device_name ? _fbb.CreateString(device_name) : 0,
      device_code ? _fbb.CreateString(device_code) : 0,
      terminal,
      ip ? _fbb.CreateString(ip) : 0,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0);
}

struct VerifyCode_rsp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RES = 4,
    VT_TIMEOUT = 6,
    VT_ADDRESS = 8
  };
  const Result *res() const {
    return GetPointer<const Result *>(VT_RES);
  }
  const flatbuffers::String *timeout() const {
    return GetPointer<const flatbuffers::String *>(VT_TIMEOUT);
  }
  const flatbuffers::String *address() const {
    return GetPointer<const flatbuffers::String *>(VT_ADDRESS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RES) &&
           verifier.VerifyTable(res()) &&
           VerifyOffset(verifier, VT_TIMEOUT) &&
           verifier.Verify(timeout()) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.Verify(address()) &&
           verifier.EndTable();
  }
};

struct VerifyCode_rspBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_res(flatbuffers::Offset<Result> res) {
    fbb_.AddOffset(VerifyCode_rsp::VT_RES, res);
  }
  void add_timeout(flatbuffers::Offset<flatbuffers::String> timeout) {
    fbb_.AddOffset(VerifyCode_rsp::VT_TIMEOUT, timeout);
  }
  void add_address(flatbuffers::Offset<flatbuffers::String> address) {
    fbb_.AddOffset(VerifyCode_rsp::VT_ADDRESS, address);
  }
  explicit VerifyCode_rspBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VerifyCode_rspBuilder &operator=(const VerifyCode_rspBuilder &);
  flatbuffers::Offset<VerifyCode_rsp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VerifyCode_rsp>(end);
    return o;
  }
};

inline flatbuffers::Offset<VerifyCode_rsp> CreateVerifyCode_rsp(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Result> res = 0,
    flatbuffers::Offset<flatbuffers::String> timeout = 0,
    flatbuffers::Offset<flatbuffers::String> address = 0) {
  VerifyCode_rspBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_timeout(timeout);
  builder_.add_res(res);
  return builder_.Finish();
}

inline flatbuffers::Offset<VerifyCode_rsp> CreateVerifyCode_rspDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Result> res = 0,
    const char *timeout = nullptr,
    const char *address = nullptr) {
  return mm::CreateVerifyCode_rsp(
      _fbb,
      res,
      timeout ? _fbb.CreateString(timeout) : 0,
      address ? _fbb.CreateString(address) : 0);
}

struct exrates_req FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACC = 4,
    VT_CUR = 6
  };
  const Account *acc() const {
    return GetPointer<const Account *>(VT_ACC);
  }
  Currency cur() const {
    return static_cast<Currency>(GetField<uint8_t>(VT_CUR, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACC) &&
           verifier.VerifyTable(acc()) &&
           VerifyField<uint8_t>(verifier, VT_CUR) &&
           verifier.EndTable();
  }
};

struct exrates_reqBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acc(flatbuffers::Offset<Account> acc) {
    fbb_.AddOffset(exrates_req::VT_ACC, acc);
  }
  void add_cur(Currency cur) {
    fbb_.AddElement<uint8_t>(exrates_req::VT_CUR, static_cast<uint8_t>(cur), 0);
  }
  explicit exrates_reqBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  exrates_reqBuilder &operator=(const exrates_reqBuilder &);
  flatbuffers::Offset<exrates_req> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<exrates_req>(end);
    return o;
  }
};

inline flatbuffers::Offset<exrates_req> Createexrates_req(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    Currency cur = Currency_NONE) {
  exrates_reqBuilder builder_(_fbb);
  builder_.add_acc(acc);
  builder_.add_cur(cur);
  return builder_.Finish();
}

struct Query_order_oprecord FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACC = 4,
    VT_PAGE = 6,
    VT_ENTRUST_NO = 8
  };
  const Account *acc() const {
    return GetPointer<const Account *>(VT_ACC);
  }
  const Query_page *page() const {
    return GetPointer<const Query_page *>(VT_PAGE);
  }
  const flatbuffers::String *entrust_no() const {
    return GetPointer<const flatbuffers::String *>(VT_ENTRUST_NO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACC) &&
           verifier.VerifyTable(acc()) &&
           VerifyOffset(verifier, VT_PAGE) &&
           verifier.VerifyTable(page()) &&
           VerifyOffset(verifier, VT_ENTRUST_NO) &&
           verifier.Verify(entrust_no()) &&
           verifier.EndTable();
  }
};

struct Query_order_oprecordBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acc(flatbuffers::Offset<Account> acc) {
    fbb_.AddOffset(Query_order_oprecord::VT_ACC, acc);
  }
  void add_page(flatbuffers::Offset<Query_page> page) {
    fbb_.AddOffset(Query_order_oprecord::VT_PAGE, page);
  }
  void add_entrust_no(flatbuffers::Offset<flatbuffers::String> entrust_no) {
    fbb_.AddOffset(Query_order_oprecord::VT_ENTRUST_NO, entrust_no);
  }
  explicit Query_order_oprecordBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Query_order_oprecordBuilder &operator=(const Query_order_oprecordBuilder &);
  flatbuffers::Offset<Query_order_oprecord> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Query_order_oprecord>(end);
    return o;
  }
};

inline flatbuffers::Offset<Query_order_oprecord> CreateQuery_order_oprecord(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    flatbuffers::Offset<Query_page> page = 0,
    flatbuffers::Offset<flatbuffers::String> entrust_no = 0) {
  Query_order_oprecordBuilder builder_(_fbb);
  builder_.add_entrust_no(entrust_no);
  builder_.add_page(page);
  builder_.add_acc(acc);
  return builder_.Finish();
}

inline flatbuffers::Offset<Query_order_oprecord> CreateQuery_order_oprecordDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Account> acc = 0,
    flatbuffers::Offset<Query_page> page = 0,
    const char *entrust_no = nullptr) {
  return mm::CreateQuery_order_oprecord(
      _fbb,
      acc,
      page,
      entrust_no ? _fbb.CreateString(entrust_no) : 0);
}

struct Order_operation_record FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DIRECTION = 4,
    VT_PRICE = 6,
    VT_QTY = 8,
    VT_OP_STATUS = 10,
    VT_INPUT_CHANNEL = 12,
    VT_INPUT_TIME = 14,
    VT_REJ_MSG = 16,
    VT_SPEC_COND = 18,
    VT_REMARK = 20,
    VT_EXTRAS = 22
  };
  Entrust_mode direction() const {
    return static_cast<Entrust_mode>(GetField<uint8_t>(VT_DIRECTION, 0));
  }
  const flatbuffers::String *price() const {
    return GetPointer<const flatbuffers::String *>(VT_PRICE);
  }
  const flatbuffers::String *qty() const {
    return GetPointer<const flatbuffers::String *>(VT_QTY);
  }
  Op_status op_status() const {
    return static_cast<Op_status>(GetField<uint8_t>(VT_OP_STATUS, 0));
  }
  TerminalType input_channel() const {
    return static_cast<TerminalType>(GetField<uint8_t>(VT_INPUT_CHANNEL, 0));
  }
  const flatbuffers::String *input_time() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT_TIME);
  }
  const flatbuffers::String *rej_msg() const {
    return GetPointer<const flatbuffers::String *>(VT_REJ_MSG);
  }
  const SpecialCond *spec_cond() const {
    return GetPointer<const SpecialCond *>(VT_SPEC_COND);
  }
  const flatbuffers::String *remark() const {
    return GetPointer<const flatbuffers::String *>(VT_REMARK);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DIRECTION) &&
           VerifyOffset(verifier, VT_PRICE) &&
           verifier.Verify(price()) &&
           VerifyOffset(verifier, VT_QTY) &&
           verifier.Verify(qty()) &&
           VerifyField<uint8_t>(verifier, VT_OP_STATUS) &&
           VerifyField<uint8_t>(verifier, VT_INPUT_CHANNEL) &&
           VerifyOffset(verifier, VT_INPUT_TIME) &&
           verifier.Verify(input_time()) &&
           VerifyOffset(verifier, VT_REJ_MSG) &&
           verifier.Verify(rej_msg()) &&
           VerifyOffset(verifier, VT_SPEC_COND) &&
           verifier.VerifyTable(spec_cond()) &&
           VerifyOffset(verifier, VT_REMARK) &&
           verifier.Verify(remark()) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           verifier.EndTable();
  }
};

struct Order_operation_recordBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_direction(Entrust_mode direction) {
    fbb_.AddElement<uint8_t>(Order_operation_record::VT_DIRECTION, static_cast<uint8_t>(direction), 0);
  }
  void add_price(flatbuffers::Offset<flatbuffers::String> price) {
    fbb_.AddOffset(Order_operation_record::VT_PRICE, price);
  }
  void add_qty(flatbuffers::Offset<flatbuffers::String> qty) {
    fbb_.AddOffset(Order_operation_record::VT_QTY, qty);
  }
  void add_op_status(Op_status op_status) {
    fbb_.AddElement<uint8_t>(Order_operation_record::VT_OP_STATUS, static_cast<uint8_t>(op_status), 0);
  }
  void add_input_channel(TerminalType input_channel) {
    fbb_.AddElement<uint8_t>(Order_operation_record::VT_INPUT_CHANNEL, static_cast<uint8_t>(input_channel), 0);
  }
  void add_input_time(flatbuffers::Offset<flatbuffers::String> input_time) {
    fbb_.AddOffset(Order_operation_record::VT_INPUT_TIME, input_time);
  }
  void add_rej_msg(flatbuffers::Offset<flatbuffers::String> rej_msg) {
    fbb_.AddOffset(Order_operation_record::VT_REJ_MSG, rej_msg);
  }
  void add_spec_cond(flatbuffers::Offset<SpecialCond> spec_cond) {
    fbb_.AddOffset(Order_operation_record::VT_SPEC_COND, spec_cond);
  }
  void add_remark(flatbuffers::Offset<flatbuffers::String> remark) {
    fbb_.AddOffset(Order_operation_record::VT_REMARK, remark);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(Order_operation_record::VT_EXTRAS, extras);
  }
  explicit Order_operation_recordBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Order_operation_recordBuilder &operator=(const Order_operation_recordBuilder &);
  flatbuffers::Offset<Order_operation_record> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Order_operation_record>(end);
    return o;
  }
};

inline flatbuffers::Offset<Order_operation_record> CreateOrder_operation_record(
    flatbuffers::FlatBufferBuilder &_fbb,
    Entrust_mode direction = Entrust_mode_NONE,
    flatbuffers::Offset<flatbuffers::String> price = 0,
    flatbuffers::Offset<flatbuffers::String> qty = 0,
    Op_status op_status = Op_status_SUCC,
    TerminalType input_channel = TerminalType_NONE,
    flatbuffers::Offset<flatbuffers::String> input_time = 0,
    flatbuffers::Offset<flatbuffers::String> rej_msg = 0,
    flatbuffers::Offset<SpecialCond> spec_cond = 0,
    flatbuffers::Offset<flatbuffers::String> remark = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0) {
  Order_operation_recordBuilder builder_(_fbb);
  builder_.add_extras(extras);
  builder_.add_remark(remark);
  builder_.add_spec_cond(spec_cond);
  builder_.add_rej_msg(rej_msg);
  builder_.add_input_time(input_time);
  builder_.add_qty(qty);
  builder_.add_price(price);
  builder_.add_input_channel(input_channel);
  builder_.add_op_status(op_status);
  builder_.add_direction(direction);
  return builder_.Finish();
}

inline flatbuffers::Offset<Order_operation_record> CreateOrder_operation_recordDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Entrust_mode direction = Entrust_mode_NONE,
    const char *price = nullptr,
    const char *qty = nullptr,
    Op_status op_status = Op_status_SUCC,
    TerminalType input_channel = TerminalType_NONE,
    const char *input_time = nullptr,
    const char *rej_msg = nullptr,
    flatbuffers::Offset<SpecialCond> spec_cond = 0,
    const char *remark = nullptr,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr) {
  return mm::CreateOrder_operation_record(
      _fbb,
      direction,
      price ? _fbb.CreateString(price) : 0,
      qty ? _fbb.CreateString(qty) : 0,
      op_status,
      input_channel,
      input_time ? _fbb.CreateString(input_time) : 0,
      rej_msg ? _fbb.CreateString(rej_msg) : 0,
      spec_cond,
      remark ? _fbb.CreateString(remark) : 0,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0);
}

struct Query_order_oprecord_rsp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RES = 4,
    VT_PAGE = 6,
    VT_EXTRAS = 8,
    VT_ITEMS = 10
  };
  const Result *res() const {
    return GetPointer<const Result *>(VT_RES);
  }
  const Query_page *page() const {
    return GetPointer<const Query_page *>(VT_PAGE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Order_operation_record>> *items() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Order_operation_record>> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RES) &&
           verifier.VerifyTable(res()) &&
           VerifyOffset(verifier, VT_PAGE) &&
           verifier.VerifyTable(page()) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.Verify(items()) &&
           verifier.VerifyVectorOfTables(items()) &&
           verifier.EndTable();
  }
};

struct Query_order_oprecord_rspBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_res(flatbuffers::Offset<Result> res) {
    fbb_.AddOffset(Query_order_oprecord_rsp::VT_RES, res);
  }
  void add_page(flatbuffers::Offset<Query_page> page) {
    fbb_.AddOffset(Query_order_oprecord_rsp::VT_PAGE, page);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(Query_order_oprecord_rsp::VT_EXTRAS, extras);
  }
  void add_items(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Order_operation_record>>> items) {
    fbb_.AddOffset(Query_order_oprecord_rsp::VT_ITEMS, items);
  }
  explicit Query_order_oprecord_rspBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Query_order_oprecord_rspBuilder &operator=(const Query_order_oprecord_rspBuilder &);
  flatbuffers::Offset<Query_order_oprecord_rsp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Query_order_oprecord_rsp>(end);
    return o;
  }
};

inline flatbuffers::Offset<Query_order_oprecord_rsp> CreateQuery_order_oprecord_rsp(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Result> res = 0,
    flatbuffers::Offset<Query_page> page = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Order_operation_record>>> items = 0) {
  Query_order_oprecord_rspBuilder builder_(_fbb);
  builder_.add_items(items);
  builder_.add_extras(extras);
  builder_.add_page(page);
  builder_.add_res(res);
  return builder_.Finish();
}

inline flatbuffers::Offset<Query_order_oprecord_rsp> CreateQuery_order_oprecord_rspDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Result> res = 0,
    flatbuffers::Offset<Query_page> page = 0,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr,
    const std::vector<flatbuffers::Offset<Order_operation_record>> *items = nullptr) {
  return mm::CreateQuery_order_oprecord_rsp(
      _fbb,
      res,
      page,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0,
      items ? _fbb.CreateVector<flatbuffers::Offset<Order_operation_record>>(*items) : 0);
}

struct ACCOUNT_INFO FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_API_TYPE = 4,
    VT_ACCOUNT = 6,
    VT_PASSWORD = 8,
    VT_EXTRAS = 10
  };
  const flatbuffers::String *api_type() const {
    return GetPointer<const flatbuffers::String *>(VT_API_TYPE);
  }
  const flatbuffers::String *account() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNT);
  }
  const flatbuffers::String *password() const {
    return GetPointer<const flatbuffers::String *>(VT_PASSWORD);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *extras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_EXTRAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_API_TYPE) &&
           verifier.Verify(api_type()) &&
           VerifyOffset(verifier, VT_ACCOUNT) &&
           verifier.Verify(account()) &&
           VerifyOffset(verifier, VT_PASSWORD) &&
           verifier.Verify(password()) &&
           VerifyOffset(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           verifier.EndTable();
  }
};

struct ACCOUNT_INFOBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_api_type(flatbuffers::Offset<flatbuffers::String> api_type) {
    fbb_.AddOffset(ACCOUNT_INFO::VT_API_TYPE, api_type);
  }
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(ACCOUNT_INFO::VT_ACCOUNT, account);
  }
  void add_password(flatbuffers::Offset<flatbuffers::String> password) {
    fbb_.AddOffset(ACCOUNT_INFO::VT_PASSWORD, password);
  }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras) {
    fbb_.AddOffset(ACCOUNT_INFO::VT_EXTRAS, extras);
  }
  explicit ACCOUNT_INFOBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACCOUNT_INFOBuilder &operator=(const ACCOUNT_INFOBuilder &);
  flatbuffers::Offset<ACCOUNT_INFO> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACCOUNT_INFO>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACCOUNT_INFO> CreateACCOUNT_INFO(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> api_type = 0,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    flatbuffers::Offset<flatbuffers::String> password = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> extras = 0) {
  ACCOUNT_INFOBuilder builder_(_fbb);
  builder_.add_extras(extras);
  builder_.add_password(password);
  builder_.add_account(account);
  builder_.add_api_type(api_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ACCOUNT_INFO> CreateACCOUNT_INFODirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *api_type = nullptr,
    const char *account = nullptr,
    const char *password = nullptr,
    const std::vector<flatbuffers::Offset<Pair>> *extras = nullptr) {
  return mm::CreateACCOUNT_INFO(
      _fbb,
      api_type ? _fbb.CreateString(api_type) : 0,
      account ? _fbb.CreateString(account) : 0,
      password ? _fbb.CreateString(password) : 0,
      extras ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*extras) : 0);
}

inline const mm::Account *GetAccount(const void *buf) {
  return flatbuffers::GetRoot<mm::Account>(buf);
}

inline bool VerifyAccountBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<mm::Account>(nullptr);
}

inline void FinishAccountBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<mm::Account> root) {
  fbb.Finish(root);
}

}  // namespace mm

#endif  // FLATBUFFERS_GENERATED_MM_MM_H_
